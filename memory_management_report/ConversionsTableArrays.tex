{}\textbf{Most Common Basic Conversions for Contiguous Array Types}
{\small\begin{tabular}{|l|l|l|l|}
%
\hline
%
Type To & Type From & Properties & C++ code (or impl function) \\
%
\hline
%
\hline
{}\ttt{ArrayRCP<S>} & \textcolor{red}{\ttt{S*}} & Sh, Ex, Ow &
{}\textcolor{red}{\ttt{arcp(s\_p,0,n)}}
${}^{\ref{conv:arcp-owning}}$\\
%
\hline
{}\ttt{ArrayRCP<S>} & \textcolor{red}{\ttt{S*}} & Sh, Ex, NOw &
{}\textcolor{red}{\ttt{arcp(s\_p,0,n,false)}}
${}^{\ref{conv:arcp-nonowning}}$\\
%
\hline
{}\ttt{ArrayRCP<S>} & \ttt{Array<S>} & Sh, Ex, NOw, DR &
{}\ttt{arcpFromArray(s\_a)}\\
%
\hline
{}\ttt{ArrayRCP<S>} & \ttt{ArrayView<S>} & Sh, Ex, NOw, DR &
{}\ttt{arcpFromArrayView(s\_av)}\\
%
\hline
{}\ttt{ArrayRCP<S>} & \ttt{ArrayView<S>} & Dp, Ex, Ow &
{}\ttt{arcpClone(s\_av)}\\
%
\hline
{}\ttt{ArrayRCP<S>} & \ttt{RCP<Array<S> >} & Sh, Ex, Ow, DR &
{}\ttt{arcp(s\_a\_rcp)}\\
%
\hline
{}\ttt{ArrayRCP<const S>} & \ttt{RCP<const Array<S> >} & Sh, Ex, Ow, DR &
{}\ttt{arcp(cs\_a\_rcp)}\\
%
\hline
{}\ttt{ArrayRCP<const S>} & \ttt{ArrayRCP<S>} & Sh, Im, Ow, DR &
{}\ttt{ArrayRCP::operator()()}\\
%
\hline
{}\textcolor{red}{\ttt{S*}} & \ttt{ArrayRCP<S>} & Sh, Ex, NOw &
{}\textcolor{red}{\ttt{s\_arcp.getRawPtr()}}
${}^{\ref{conv:array-expose-raw-ptr}}$\\
%
\hline
{}\textcolor{blue}{\ttt{S\&}} & \ttt{ArrayRCP<S>} & Sh, Ex, NOw &
{}\textcolor{blue}{\ttt{s\_arcp[i]}}
${}^{\ref{conv:array-expose-raw-ref}}$\\
%
\hline
%
\hline
{}\ttt{ArrayView<S>} & \textcolor{red}{\ttt{S*}} & Sh, Ex, NOw &
{}\textcolor{red}{\ttt{arrayView(s\_p,n)}}
${}^{\ref{conv:arcp-owning}}$\\
%
\hline
{}\ttt{ArrayView<S>} & \ttt{Array<S>} & Sh, Im, NOw, DR &
{}\ttt{Array::operator ArrayView()}\\
%
\hline
{}\ttt{ArrayView<S>} & \ttt{Tuple<S>} & Sh, Im, NOw, DR &
{}\ttt{Tuple::operator ArrayView()}\\
%
\hline
{}\ttt{ArrayView<S>} & \ttt{std::vector<S>} & Sh, Im, NOw &
{}\ttt{ArrayView<S>(s\_v)}\\
%
\hline
{}\ttt{ArrayView<S>} & \ttt{ArrayRCP<S>} & Sh, Ex, NOw, DR &
{}\ttt{ArrayRCP::operator()()}\\
%
\hline
{}\ttt{ArrayView<const S>} & \ttt{const Array<S>} & Sh, Im, NOw, DR &
{}\ttt{Array::operator ArrayView()}\\
%
\hline
{}\ttt{ArrayView<const S>} & \ttt{const Tuple<S>} & Sh, Im, NOw, DR &
{}\ttt{Tuple::operator ArrayView()}\\
%
\hline
{}\ttt{ArrayView<const S>} & \ttt{const std::vector<S>} & Sh, Im, NOw &
{}\ttt{ArrayView(cs\_v)}\\
%
\hline
{}\ttt{ArrayView<const S>} & \ttt{ArrayRCP<const S>} & Sh, Ex, NOw, DR &
{}\ttt{ArrayRCP::operator ArrayView()}\\
%
\hline
{}\textcolor{red}{\ttt{S*}} & \ttt{ArrayView<S>} & Ex, NOw &
{}\textcolor{red}{\ttt{s\_av.getRawPtr()}}
${}^{\ref{conv:array-expose-raw-ptr}}$\\
%
\hline
{}\textcolor{blue}{\ttt{S\&}} & \ttt{ArrayView<S>} & Ex, NOw &
{}\textcolor{blue}{\ttt{s\_av[i]}}
${}^{\ref{conv:array-expose-raw-ref}}$\\
%
\hline
%
\hline
{}\ttt{Array<S>} & {}\textcolor{red}{\ttt{S*}} & Dp, Ex &
{}\textcolor{red}{\ttt{Array<S>(s\_p,s\_p+n)}}\\
%
\hline
{}\ttt{Array<S>} & {\ttt{std::vector<S>}} & Dp, Im &
{}\ttt{Array<S>(s\_v)}\\
%
\hline
{}\ttt{Array<S>} & {}\ttt{ArrayView<S>} & Dp, Im &
{}\ttt{Array<S>(s\_av)}\\
%
\hline
{}\ttt{Array<S>} & {}\ttt{Tuple<S,N>} & Dp, Im &
{}\ttt{Array<S>(s\_t)}\\
%
\hline
{}\ttt{Array<S>} & {}\ttt{ArrayRCP<S>} & Dp, Ex &
{}\ttt{Array<S>(s\_arcp());}\\
%
\hline
{}\ttt{std::vector<S>} & {}\ttt{Array<S>} & Dp, Ex &
{}\ttt{s\_a.toVector();}\\
%
\hline
{}\textcolor{red}{\ttt{S*}} & \ttt{Array<S>} & Ex, NOw &
{}\textcolor{red}{\ttt{s\_a.getRawPtr()}}
${}^{\ref{conv:array-expose-raw-ptr}}$\\
%
\hline
{}\textcolor{blue}{\ttt{S\&}} & \ttt{Array<S>} & Ex, NOw &
{}\textcolor{blue}{\ttt{s\_a[i]}}
${}^{\ref{conv:array-expose-raw-ref}}$\\
%
\hline
%
\end{tabular} \\[3ex]
%
\begin{minipage}{\textwidth}

Types/identifiers: {}\ttt{S* s\_p};$\;\;\;\;$ {}\ttt{ArrayView<S>
s\_av};$\;\;\;\;$ {}\ttt{ArrayRCP<S> s\_arcp};$\;\;\;\;$ {}\ttt{Array<S>
s\_a};$\;\;\;\;$ {}\ttt{Tuple<S,N> s\_t};$\;\;\;\;$ {}\ttt{std::vector<S>
s\_v};$\;\;\;\;$ {}\ttt{RCP<Array<S> > s\_a\_rcp};$\;\;\;\;$ {}\ttt{RCP<const
Array<S> > cs\_a\_rcp}; \\

Properties: Sh = Shallow copy, Dp = Deep copy (dangling references not
an issue), Im = Implicit conversion, Ex = Explicit conversion, Ow =
Owning (dangling references not an issue), NOw = Non-Owning, DR =
Dangling Reference debug-mode runtime detection for non-owning

\begin{enumerate}
%
{}\item\label{conv:arcp-owning}\textcolor{red}{It should never be
necessary to convert from a raw pointer to an owning {}\ttt{ArrayRCP}
object directly.  Instead, use the non-member constructor
{}\ttt{arcp<S>(n)}.}
%
{}\item\label{conv:arcp-nonowning}\textcolor{red}{Constructing a
non-owning {}\ttt{ArrayRCP} or {}\ttt{ArrayView} directly from a raw
C++ pointer should never be needed in fully compliant code.  However,
when inter-operating with non-compliant code (or code in an intermediate
state of refactoring) this type of conversion will be needed.}
%
{}\item\label{conv:array-expose-raw-ptr}\textcolor{red}{Exposing a raw
C++ pointer should never be necessary in compliant code but may be
necessary when inter-operating with external code (see Section
{}\ref{sec:role-of-raw-pointers}).}
%
{}\item\label{conv:array-expose-raw-ref}\textcolor{blue}{Exposing a
raw C++ reference will be common in compliant code but should only be
used for non-persisting associations.}
%
\end{enumerate}

\end{minipage}}
