%
\section{\texttt{RefCountPtr<>} Quickstart and Reference}
\label{rcp:apdx:quickstart}
%

The following class hierarchy will be used in the following
examples.
%
{\small\begin{verbatim}
class A { public: virtual ~A(){} A& operator=(const A&){} virtual void f(){} };
class B1 : virtual public A {};
class B2 : virtual public A {};
class C : virtual public B1, virtual public B2 {};
class D {};
class E : public D {};
\end{verbatim}}
%
Also, all of example code is assumed to be in the namespace
\texttt{Teuchos}.

\begin{enumerate}

\item {\bf Creation of \texttt{RefCountPtr<>} objects}

\begin{enumerate}

\item {\bf Creating a \texttt{RefCountPtr<>} object uisng \texttt{new}}
%
{\small\begin{verbatim}
RefCountPtr<C> c_ptr = rcp(new C);
\end{verbatim}}
%
\item {\bf Initializing a \texttt{RefCountPtr<>} object to NULL}
%
{\small\begin{verbatim}
RefCountPtr<C> c_ptr;
\end{verbatim}}
or
{\small\begin{verbatim}
RefCountPtr<C> c_ptr = null;
\end{verbatim}}
%
\item {\bf Initializing a \texttt{RefCountPtr<>} object to an object
       \underline{not} allocated with \texttt{new}}
%
{\small\begin{verbatim}
C               c;
RefCountPtr<C>  c_ptr = rcp(&c,false);
\end{verbatim}}
%
\item {\bf Copy constructor (implicit casting)}
%
{\small\begin{verbatim}
RefCountPtr<C>      c_ptr  = rcp(new C); // No cast
RefCountPtr<A>      a_ptr  = c_ptr;      // Cast to base class
RefCountPtr<constA> ca_ptr = a_ptr;      // Cast from non-const to const
\end{verbatim}}
%
\end{enumerate}

\item {\bf Accessing the reference-counted object}
%
\begin{enumerate}
%
\item {\bf Access to object reference (runtime checked)}
%
{\small\begin{verbatim}
C &c_ref = &c_ptr;
\end{verbatim}}
%
\item {\bf Access to object pointer (unchecked, may return \texttt{NULL})}
%
{\small\begin{verbatim}
C *c_rptr = c_ptr.get();
\end{verbatim}}
%
\item {\bf Access to object pointer (runtime checked, will not return \texttt{NULL})}
%
{\small\begin{verbatim}
C *c_rptr = &*c_ptr;
\end{verbatim}}
%
\item {\bf Access of object member (runtime checked)}
%
{\small\begin{verbatim}
c_ptr->f();
\end{verbatim}}
%
\end{enumerate}

\item {\bf Casting}
%
\begin{enumerate}
%
\item {\bf Implicit casting (copy constructor)}
%
{\small\begin{verbatim}
RefCountPtr<C>      c_ptr  = rcp(new C); // No cast
RefCountPtr<A>      a_ptr  = c_ptr;      // Cast to base class
RefCountPtr<constA> ca_ptr = a_ptr;      // Cast from non-const to const
\end{verbatim}}
%
\item {\bf Casting away \texttt{const}}
%
{\small\begin{verbatim}
RefCountPtr<const A>  ca_ptr = rcp(new C);
RefCountPtr<A>        a_ptr  = rcp_const_cast<A>(ca_ptr);
\end{verbatim}}
%
\item {\bf Static cast (no runtime check)}
%
{\small\begin{verbatim}
RefCountPtr<D>     d_ptr = rcp(new E);
RefCountPtr<E>     e_ptr = rcp_static_cast<E>(d_ptr); // Unchecked, unsafe!
\end{verbatim}}
%
\item {\bf Dynamic cast (rutime check)}
%
{\small\begin{verbatim}
RefCountPtr<A>     a_ptr  = rcp(new C);                   // Implicit cast
RefCountPtr<B1>    b1_ptr = rcp_dynamic_cast<B1>(a_ptr);  // Checked, safe!
RefCountPtr<B2>    b2_ptr = rcp_dynamic_cast<B2>(b1_ptr); // Checked, safe!
RefCountPtr<B2>    c_ptr  = rcp_dynamic_cast<C>(b2_ptr);  // Checked, safe!
\end{verbatim}}
%
\end{enumerate}


\end{enumerate}
