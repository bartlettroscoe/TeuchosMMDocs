\documentclass[pdf,ps2pdf,11pt]{SANDreport}
\usepackage{pslatex}

%Local stuff
\usepackage{graphicx}
\usepackage{latexsym}
\input{rab_commands}

\newtheorem{commandment}{Commandment}
\newtheorem{anticommandment}{Anti-Commandment}

% If you want to relax some of the SAND98-0730 requirements, use the "relax"
% option. It adds spaces and boldface in the table of contents, and does not
% force the page layout sizes.
% e.g. \documentclass[relax,12pt]{SANDreport}
%
% You can also use the "strict" option, which applies even more of the
% SAND98-0730 guidelines. It gets rid of section numbers which are often
% useful; e.g. \documentclass[strict]{SANDreport}

% ---------------------------------------------------------------------------- %
%
% Set the title, author, and date
%

\title{\center
{\Huge\bf Teuchos::RCP Beginner's Guide}\\[1.5ex]
An Introduction to the Trilinos Smart Reference-Counted Pointer
Class for (Almost) Automatic Dynamic Memory Management in C++
}
\author{
Roscoe A. Bartlett \\ Optimization and Uncertainty Estimation \\
Sandia National Laboratories\footnote{
Sandia is a multiprogram laboratory operated by Sandia Corporation, a
Lockheed-Martin Company, for the United States Department of Energy
under Contract DE-AC04-94AL85000.}, Albuquerque NM 87185 USA, \\
}
\date{}

% ---------------------------------------------------------------------------- %
% Set some things we need for SAND reports. These are mandatory
%
\SANDnum{SAND2004-3268 (Updated December 2007)}
\SANDprintDate{December 2007}
\SANDauthor{
Roscoe A. Bartlett \\ Optimization and Uncertainty Estimation
}

% ---------------------------------------------------------------------------- %
% The following definitions are optional. The values shown are the default
% ones provided by SANDreport.cls
%
\SANDreleaseType{Unlimited Release}
%\SANDreleaseType{Not approved for release outside Sandia}

% ---------------------------------------------------------------------------- %
% The following definition does not have a default value and will not
% print anything, if not defined
%
%\SANDsupersed{SAND1901-0001}{January 1901}

% ---------------------------------------------------------------------------- %
%
% Start the document
%
\begin{document}

\maketitle

% ------------------------------------------------------------------------ %
% An Abstract is required for SAND reports
%

%
\begin{abstract}
%
Dynamic memory management in C++ is one of the most common areas of
difficulty and errors for amateur and expert C++ developers alike.
The improper use of operator {}\texttt{new} and operator
{}\texttt{delete} is arguably the most common cause of incorrect
program behavior and segmentation faults in C++ programs.  Here we
introduce a templated concrete C++ class
{}\texttt{Teuchos\-::RCP}, which is part of the Trilinos
tools package {}\texttt{Teuchos}, that combines the concepts of smart
pointers and reference counting to build a low-overhead but effective
tool for simplifying dynamic memory management in C++.  We discuss why
the use of raw pointers for memory management, managed through
explicit calls to operator {}\texttt{new} and operator
{}\texttt{delete}, is so difficult to accomplish without making
mistakes and how programs that use raw pointers for memory management
can easily be modified to use {}\texttt{RCP}.  In
addition, explicit calls to operator {}\texttt{delete} is fragile and
results in memory leaks in the presents of C++ exceptions.  In its
most basic usage, {}\texttt{RCP} automatically
determines when operator {}\texttt{delete} should be called to free an
object allocated with operator {}\texttt{new} and is not fragile in
the presents of exceptions.  The class also supports more
sophisticated use cases as well.  This document describes just the
most basic usage of {}\texttt{RCP} to allow developers
to get started using it right away.  However, more detailed
information on the design and advanced features of
{}\texttt{RCP} is provided by the companion document
``Teuchos::RCP : The Trilinos Smart Reference-Counted Pointer
Class for (Almost) Automatic Dynamic Memory Management in C++''.
%
\end{abstract}
%

% ------------------------------------------------------------------------ %
% An Acknowledgement section is optional but important, if someone made
% contributions or helped beyond the normal part of a work assignment.
% Use \section* since we don't want it in the table of context
%
\clearpage
\section*{Acknowledgments}

The author would like to thank Carl Laird, Heidi Thornquist, Mike
Heroux and Marzio Sala for comments on earlier drafts of this
document.

The format of this report is based on information found
in~\cite{Sand98-0730}.

% ------------------------------------------------------------------------ %
% The table of contents and list of figures and tables
% Comment out \listoffigures and \listoftables if there are no
% figures or tables. Make sure this starts on an odd numbered page
%
\clearpage
\tableofcontents
%\listoffigures
%\listoftables

% ---------------------------------------------------------------------- %
% This is where the body of the report begins; usually with an Introduction
%
\SANDmain % Start the main part of the report

%
\section{Introduction}
%

The main purpose of this document is to provide a quick-start guide on
how to incorporate the reference-counting smart pointer class
{}\texttt{Teuchos\-::RCP} into C++ programs that use
dynamic memory allocation and object orientation.  This code is
included in the Trilinos {}\cite{ref:Trilinos-Overview} tools package
{}\texttt{Teuchos}.  The design of
{}\texttt{Teuchos\-::RCP} is based partly on the
interface for {}\texttt{std\-::auto\-\_ptr<>} and Items 28 and 29 in
"More Effective C++" {}\cite{ref:meyers_1996}.  In short,
{}\texttt{RCP} allows one client to dynamically create
an object (using operator {}\texttt{new} for instance), pass the
object around to other clients that need to access the object and
never require any client to explicitly call operator
{}\texttt{delete}.  The object will (almost magically) be deleted when
all of the clients remove their references to the object.  In
principle, this is very similar to the type of garbage collection that
is in languages like Perl and Java.  There are some pathological cases
(such as the classic problem of circular references, see {}\cite[Item
29, page 212]{ref:meyers_1996}) where {}\texttt{RCP}
will result in a memory leak, but these situations can be avoided
through the careful use of {}\texttt{RCP}.  However,
realizing the potential of hands-off garbage collection with
{}\texttt{RCP} requires following some rules.  These
rules are partially spelled out in the form of commandments in
Appendix {}\ref{rcpqs:apdx:commandments}.

Note that direct calls to operator {}\texttt{delete} are discouraged
in modern C++ programs that are designed to be robust in the presence
of C++ exception handing.  This is because the raw use of operator
{}\texttt{delete} often results in memory leaks when exceptions are
thrown.  For example, in the code fragment:

{\small\begin{verbatim}
void someFunction() {
  A *a = new A;
  a->f();
  delete a;
}
\end{verbatim}}

{}\noindent{}if an exception is thrown in the function call
{}\texttt{a->f()} then the statement {}\texttt{delete a} will never be
executed and a memory leak will have been created.  The class
{}\texttt{std::auto\_\-ptr<>} was added to the standard C++ library
(see {}\cite[Items 9 and 10]{ref:meyers_1996}) to protect against
these types of memory leaks.  For example, the rewritten function:

{\small\begin{verbatim}
void someFunction() {
  std::auto_ptr<A> a(new A);
  a->f();
}
\end{verbatim}}

{}\noindent{}is robust in the event of exceptions and no memory leak
will occur.  However, {}\texttt{std::auto\_\-ptr<>} can not be used to
share a resource between two or more clients and therefore is not an
answer to the issue of general garbage collection.  The class
{}\texttt{RCP} not only is robust in the event of
exceptions but also implements reference counting and is therefore
more general (but admittedly more complex and expensive) than
{}\texttt{std::auto\_\-ptr<>}.

The use of {}\texttt{RCP} is critically important in the
development and maintenance of large complex object-oriented programs
composed of many separately-developed pieces (such as Trilinos).  This
discussion assumes that the reader has a basic familiarity and some
programming experience with C++ and has at least been exposed to the
basic concepts of object-oriented programming (good sources include
{}\cite{ref:gama_et_al_1995} and {}\cite{ref:stroustrup_2000}).
Furthermore, the reader should be comfortable with the use of C++
pointers and references.

The appendices contain basic reference material for {}\texttt{RCP}.  In many
respects, the appendices are the most important contribution of this document.
For those readers that like to see the C++ declarations right away, Appendix
{}\ref{rcpqs:apdx:c++decl} contains the C++ declarations for the template
class {}\texttt{RCP} and some important associated non-member templated
functions.  Appendix {}\ref{rcpqs:apdx:quickstart} is a short
reference-card-like quick-start for the use of {}\texttt{RCP}.  The
quick-start in this appendix shows how to create {}\texttt{RCP} objects from
raw C++ pointers, how to represent different forms on constantness, cast from
one pointer type to another, access the underlying reference-counted object as
well as to associate and manage extra data.  Appendix
{}\ref{rcpqs:apdx:commandments} gives some commandments for the use of
{}\texttt{RCP} and reinforces the material in Appendix
{}\ref{rcpqs:apdx:quickstart}.  Appendix {}\ref{rcpqs:apdx:passing-args} gives
tables of recommended idioms for how to pass raw C++ objects and
{}\texttt{RCP}-wrapped objects to and from functions.  Appendix
{}\ref{rcpqs:apdx:ex-prg} gives a listing for an example program that uses raw
pointer variables and direct calls to operator {}\texttt{new} and operator
{}\texttt{delete} while Appendix {}\ref{rcpqs:apdx:ex-prg-refactored} shows a
refactoring of this example program to use {}\texttt{RCP}.

{}\textbf{Note!}  Anxious readers are encouraged to jump directly to
Appendix {}\ref{rcpqs:apdx:ex-prg} and
{}\ref{rcpqs:apdx:ex-prg-refactored} to get an idea of what
{}\texttt{RCP} is all about.  This example, together
with the reference material in the appendices, should be enough for
semi-experienced C++ developers to start using
{}\texttt{RCP} right away.

For less anxious readers, in the following section, we describe why the use of
raw C++ pointers and raw calls to operator {}\texttt{new} and especially
operator {}\texttt{delete} is difficult to program correctly in even
moderately complex C++ programs.  We then discuss the different ways C++
pointers are used in such programs and describe how to refactor these programs
to replace some of the raw C++ pointers and raw calls to operator
{}\texttt{delete} with {}\texttt{RCP}.  In the following discussion we will
define {}\textit{persisting} and {}\textit{non-persisting} associations and
will make a distinction between them (see page
{}\pageref{rcp:non-persisting-defined}).  {}\texttt{RCP} is recommended for
use only with {}\textit{persisting} associations.  The consistent use of
{}\texttt{RCP} extends the vocabulary of C++ in helping to distinguish between
these two types of relationships.  In addition, {}\texttt{RCP} is designed for
the memory management of individual objects, not raw C++ arrays of objects.
Array allocation and deallocation should be performed using standard C++
containers such as {}\texttt{std\-::vector<>}, {}\texttt{std\-::valarray<>} or
some other such convenient C++ array class but the best choice is typically a
debug range-checked class like {}\texttt{Teuchos\-::Array}.  However, it is
quite common to dynamically allocate arrays of {}\texttt{RCP} objects and use
{}\texttt{RCP} to manage the lifetime of such array class objects.

%
\section{An example C++ program}
%

The use of object-oriented (OO) programing in C++ is the major
motivation for the development of {}\texttt{RCP}.  OO
programs are characterized by the use of abstract classes
(i.e.~interfaces) and concrete subclasses (i.e.~implementations).  In
OO programs it is common that the selection of which concrete
subclass(es) to use is not known until runtime.  The ``Abstract
Factory'' {}\cite{ref:gama_et_al_1995} is a popular design pattern
that allows the flexible runtime selection of what concrete subclasses
to create.

Below we describe a fictitious program that demonstrates some of the
typical features of an OO program that uses dynamic memory management
in C++.  In this simple program, handling memory management using raw
C++ pointers and calls to operator {}\texttt{new} and operator
{}\texttt{delete} will appear fairly easy but larger more realistic OO
programs are much more complicated and it is definitely not easy to do
memory management without some help.

%
\subsection{Example C++ program using raw dynamic memory management}
\label{rcpbg:sec:original-program}
%

One of the predominate features of this example program is the use of
the following abstract interface base class {}\texttt{Utility\-Base}
that defines an interface to provide some useful capability.

{\small\begin{verbatim}
class UtilityBase {
public:
  virtual void f() const = 0;
};
\end{verbatim}}

In our example program, {}\texttt{Utility\-Base} will have two
subclasses where one or the other will be used at runtime.

{\small\begin{verbatim}
class UtilityA : public UtilityBase {
public:
  void f() const { std::cout<<"\nUtilityA::f() called, this="<<this<<"\n"; }
};

class UtilityB : public UtilityBase {
public:
  void f() const { std::cout<<"\nUtilityB::f() called, this="<<this<<"\n"; }
};
\end{verbatim}}

{}\noindent{}In this example program the above implementation
functions just print to standard out.

Some of the clients in this program have to create
{}\texttt{Utility\-Base} objects without knowing exactly what concrete
subclasses are being used.  This is accomplished through the use of
the ``Abstract Factory'' design pattern {}\cite{ref:gama_et_al_1995}.
For {}\texttt{Utility\-Base}, the abstract factory looks like

{\small\begin{verbatim}
class UtilityBaseFactory {
public:
  virtual UtilityBase* createUtility() const = 0;
};
\end{verbatim}}

{}\noindent{}and has the following factory subclasses for creating
{}\texttt{Utility\-A} and {}\texttt{Utility\-B} objects.

{\small\begin{verbatim}
class UtilityAFactory : public UtilityBaseFactory {
public:
  UtilityBase* createUtility() const { return new UtilityA(); }
};

class UtilityBFactory : public UtilityBaseFactory {
public:
  UtilityBase* createUtility() const { return new UtilityB(); }
};
\end{verbatim}}

Now let's assume that our example program has the following client
classes.

{\small\begin{verbatim}
// Simple client with no state
class ClientA {
public:
  void f( const UtilityBase &utility ) const { utility.f(); }
};

// Client that maintains a pointer to a Utility object 
class ClientB {
  UtilityBase *utility_;
public:
  ClientB() : utility_(0) {}
  ~ClientB() { delete utility_; }
  void initialize( UtilityBase *utility ) { utility_ = utility; }
  void g( const ClientA &a ) { a.f(*utility_); }
};

// Client that maintains pointers to UtilityFactory and Utility objects
class ClientC {
  const UtilityBaseFactory *utilityFactory_;
  UtilityBase *utility_;
  bool shareUtility_;
public:
  ClientC( const UtilityBaseFactory *utilityFactory, bool shareUtility )
    :utilityFactory_(utilityFactory),
    utility_(utilityFactory->createUtility())
    ,shareUtility_(shareUtility) {}
  ~ClientC() { delete utilityFactory_; delete utility_; }
  void h( ClientB *b ) {
    if( shareUtility_ ) b->initialize(utility_);
    else  b->initialize(utilityFactory_->createUtility());
  }
};
\end{verbatim}}

The type of logic used in {}\texttt{ClientC} for determining when new
objects should be created or when objects should be reused and passed
around is common in larger more complicated OO programs.

The above client classes demonstrate two different types of
associations between objects: {}\textit{non-persisting} and
{}\textit{persisting}.

{}\textit{Non-Persisting}\label{rcp:non-persisting-defined}
associations exist only within a single function call and do not
extend after the function has finished executing.  For example,
objects of type {}\texttt{Client\-A} and {}\texttt{Utility\-Base} have
a non-persisting relationship through the function
{}\texttt{ClientA\-::f(const UtilityBase \&utility)}.  Likewise,
objects of type {}\texttt{Client\-B} and {}\texttt{Client\-A} have a
non-persisting association through the function
{}\texttt{ClientB\-::g( const ClientA
\&a )}.

{}\textit{Persisting}\label{rcp:persisting-defined} associations are
where a relationship between two objects exists past a single function
call.  The most typical kind of persisting association in an OO C++
program is where one object maintains a private pointer data member to
another object.  For example, persisting associations exist between a
{}\texttt{ClientC} object, a {}\texttt{Utility\-Base\-Factory} and a
{}\texttt{Utility\-Base} object through the the private C++ pointer
data members {}\texttt{ClientC\-::utility\-Factory\_} and
{}\texttt{ClientC\-::utility\_} respectively.  Likewise, a persisting
association exists between a {}\texttt{ClientB} object and a
{}\texttt{Utility\-Base} object through the private pointer data
member {}\texttt{ClientB\-::utility\_}.

Persisting relationships are significantly more complex than
non-persisting relationships since a persisting relationship usually
implies that some objects must be responsible for the lifetime of
other objects.  This is never the case in a non-persisting relationship as
defined above.

Appendix {}\ref{rcpqs:apdx:ex-prg} shows an example program that uses
all of the C++ classes described above.  The program in Appendix
{}\ref{rcpqs:apdx:ex-prg} has several memory management problems. An
astute reader will notice that the {}\texttt{Utility\-Base\-Factory}
created in {}\texttt{main()} gets deleted twice; once in the
destructor for the {}\texttt{ClientC} object {}\texttt{c} and again at
the end of {}\texttt{main()} in an explicit call to operator
{}\texttt{delete}.  This problem could be fixed in this program by
arbitrating ``ownership'' of the {}\texttt{Utility\-Base\-Factory}
object to either {}\texttt{main()} or the {}\texttt{ClientC} object,
but not both which is the case in Appendix {}\ref{rcpqs:apdx:ex-prg}.

A more difficult memory management problem to catch and fix occurs in
the {}\texttt{ClientB} and {}\texttt{ClientC} objects regrading a
shared {}\texttt{Utility\-Base} object.  When {}\texttt{shareUtility}
is set to {}\texttt{false} (by the user in the commandline arguments)
the objects {}\texttt{b1}, {}\texttt{b2} and {}\texttt{c} each own a
pointer to different {}\texttt{Utility\-Base} objects and the software
will correctly delete each dynamically allocated object using one and
only one call to operator {}\texttt{delete} (in the destructors of
these classes).  However, when {}\texttt{shareUtility} is to set to
{}\texttt{true} the objects {}\texttt{b1}, {}\texttt{b2} and
{}\texttt{c} will contain pointers to the same
{}\texttt{Utility\-Base} object and operator {}\texttt{delete} will be
called on this shared {}\texttt{Utility\-Base} object multiple times
when {}\texttt{b1}, {}\texttt{b2} and {}\texttt{c} are destroyed.  In
this case, it is not so easy to arbitrate ownership of the shared
{}\texttt{Utility\-Base} object to the {}\texttt{ClientB} or the
{}\texttt{ClientC} objects.  Logic could be developed in this simple
program to insure that ownership was assigned properly but such logic
would enlarge the program, complicate maintenance, and would
ultimately make the software components less reusable.  In more
complex programs, trying to dynamically arbitrate ownership at run
time is much more difficult and error prone if done manually.

%
\subsection{Refactored example C++ program using {}\texttt{Teuchos::RCP}}
\label{rcpbg:sec:refactored-program}
%

Now we describe how {}\texttt{RCP} can be used to
greatly simplify dynamic memory management in these types of OO
programs.  Appendix {}\ref{rcpqs:apdx:ex-prg-refactored} shows the
refactoring of the program in Appendix {}\ref{rcpqs:apdx:ex-prg} to
use {}\texttt{RCP} for all persisting relationships.
In general, refactoring software that uses raw C++ pointers to use
{}\texttt{RCP} is as simple as replacing the type
{}\texttt{T*} with {}\texttt{RCP<T>}, where {}\texttt{T}
is nearly any class or built-in data type.

The first persisting relationship for which
{}\texttt{RCP} is used is the relationship between a
{}\texttt{Utility\-Base\-Factory} object and a client that uses it.
The refactoring changes the return type of
{}\texttt{Utility\-Base\-Factory\-::createUtility()} from a raw
{}\texttt{Utility\-Base*} pointer to a
{}\texttt{RCP<Utility\-Base>} object.  The new ``Abstract
Factory'' class declarations (assuming that the symbols from the
{}\texttt{Teuchos} namespace are in scope so that explicit
{}\texttt{Teuchos::} qualification is not necessary) become

{\small\begin{verbatim}
class UtilityBaseFactory {
public:
  virtual RCP<UtilityBase> createUtility() const = 0;
};

class UtilityAFactory : public UtilityBaseFactory {
public:
  RCP<UtilityBase> createUtility() const { return rcp(new UtilityA()); }
};

class UtilityBFactory : public UtilityBaseFactory {
public:
  RCP<UtilityBase> createUtility() const { return rcp(new UtilityB()); }
};
\end{verbatim}}

In addition to the change of the return type, the refactoring also
requires that calls to operator {}\texttt{new} be wrapped in calls to
the templated function {}\texttt{Teuchos\-::rcp(...)}.

The refactoring shown in Appendix {}\ref{rcpqs:apdx:ex-prg-refactored}
does not impact the definition of the class {}\texttt{ClientA} since
this class does not have any persisting relationships with any
other objects.  However, the definitions of the classes
{}\texttt{ClientB} and {}\texttt{ClientC} do change and become

{\small\begin{verbatim}
class ClientB {
  RCP<UtilityBase> utility_;
public:
  void initialize(const RCP<UtilityBase> &utility) { utility_=utility; }
  void g( const ClientA &a ) { a.f(*utility_); }
};

class ClientC {
  RCP<UtilityBaseFactory> utilityFactory_;
  RCP<UtilityBase> utility_;
  bool shareUtility_;
public:
  ClientC( const RCP<UtilityBaseFactory> &utilityFactory, bool shareUtility )
    :utilityFactory_(utilityFactory),
    utility_(utilityFactory->createUtility())
    ,shareUtility_(shareUtility) {}
  void h( const Ptr<ClientB> &b ) {
    if( shareUtility_ ) b->initialize(utility_);
    else b->initialize(utilityFactory_->createUtility());
  }
};
\end{verbatim}}

The first thing that one should notice about the refactored
{}\texttt{ClientB} and {}\texttt{ClientC} classes is that their
destructors are gone.  It turns out that the compiler-generated
destructors do exactly the correct thing (i.e.~call the destructor on
the {}\texttt{RCP} data members which in turns calls
operator {}\texttt{delete} on the underlying reference-counted object
when the reference count goes to zero).  The second thing that one
should notice is that the old default constructor
{}\texttt{ClientB::ClientB()} which initialized the raw C++ pointer
{}\texttt{utility\_} to null is no longer needed since
{}\texttt{RCP} has a default constructor that does that.
A third thing to notice about these refactored client classes is that
the {}\texttt{RCP} objects are passed by
{}\texttt{const} reference (see Appendix
{}\ref{rcpqs:apdx:passing-args}) and not by value as the corresponding
raw pointers where in the original unfactored classes.  Passing
{}\texttt{RCP} objects by {}\texttt{const} reference
yields slightly more efficient code and simplifies stepping through
the code in a debugger.  For example, a function declared as

{\small\begin{verbatim}
void someFunction( RCP<A> a );
\end{verbatim}}

{}\noindent{}will always result in the copy constructor for
{}\texttt{RCP} being called (and therefore stepped into
in a debugger) while this same function declared as:

{\small\begin{verbatim}
void someFunction( const RCP<A> &a );
\end{verbatim}}

{}\noindent{}will often not require the copy constructor be called
(except in cases where an implicit conversion is being performed as
described in Appendix {}\ref{rcpqs:apdx:quickstart}) and thereby
easing debugging.

Lastly, above, the class {}\texttt{Ptr} is a Teuchos non-reference-counted
smart pointer class designed to avoid raw pointers.  It is used for
non-persisting associations where a raw pointer would otherwise be used.
{}\texttt{Ptr} initializes to NULL and in debug mode it will throw exception
exceptions when dereferencing NULL.  {}\texttt{Ptr} plays a small role in the
overall strategy to avoid all raw C++ pointers at the application programming
level.

As an aside, note that Appendix {}\ref{rcpqs:apdx:passing-args} gives
recommended idioms for how to pass raw C++ objects and
{}\texttt{RCP}-wrapped objects to and from functions in
a way that result in function prototypes becoming as self documenting
as possible, help to avoid coding errors and increase the readability
of C++ code.  Also, in addition to the benefit that
{}\texttt{RCP} eases dynamic memory management, the
selective use of {}\texttt{RCP} and raw C++ object
references extends the vocabulary of the C++ language by helping to
distinguish between persisting and non-persisting associations.  For
example, when a one sees a function prototype where an object is
passed through a {}\texttt{RCP} such as

{\small\begin{verbatim}
class SomeClass {
public:
  void someFunction( const RCP<A> &a );
}
\end{verbatim}}

{}\noindent{}one can automatically deduce that ``memory'' of the
{}\texttt{A} object will be retained (through a private
{}\texttt{RCP<A>} data member in {}\texttt{Some\-Class} no
doubt) and that should automatically alter how the developer plans on
calling that function and passing the {}\texttt{A} object.  The
refactored C++ program in Appendix
{}\ref{rcpqs:apdx:ex-prg-refactored} provides an example of how the
idioms presented in Appendix {}\ref{rcpqs:apdx:passing-args} are put
to use.

%
\section{Additional and advanced features of {}\texttt{RCP}}
%

The use cases for {}\texttt{RCP} described above
comprise a large majority of the relavent use cases in most programs,
but there there are some other use cases that require additional and
more advanced features.  Some of these additional features (the C++
declarations for which are shown in Appendix
{}\ref{rcpqs:apdx:c++decl}) are mentioned below:

\begin{enumerate}

\item \textbf{Casting}

{}\texttt{RCP} objects can be casted in a manner similar
to casting raw C++ pointers and the same types of conversion rules
apply.  Analogs of the built-in casts {}\texttt{static\_\-cast<>},
{}\texttt{const\_\-cast<>} and {}\texttt{dynamic\_\-cast<>} are
supported by the non-member templated functions
{}\texttt{rcp\_\-static\_\-cast<>}, {}\texttt{rcp\_\-const\_\-cast<>}
and {}\texttt{rcp\_\-dynamic\_\-cast<>} respectively.  See Appendix
{}\ref{rcpqs:apdx:quickstart} for examples of how they are used.

\item \textbf{Reference-count information}

The function {}\texttt{RCP\-::count()} returns the
number of {}\texttt{RCP} objects that point to the
underlying reference-counted object.  This information can be useful
in some cases.

\item \textbf{Customized deallocation policies}

The default behavior of {}\texttt{RCP} is to call
operator {}\texttt{delete} on reference-counted objects once the
reference count goes to zero.  While this is the most commonly needed
behavior, there are use cases where more specialized dellocation
polices are required.  For these cases, there is an overloaded form of
the templated function {}\texttt{Teuchos\-::rcp(...)} that takes a
templated deallocation policy object that defines how a
reference-counted object is deallocated when required.

\item \textbf{Associating extra data with a reference-counted object}

There are some more difficult use cases where certain types of information or
other objects must be bundled with a reference-counted object and must not be
deleted until the reference-counted object is deleted.  The non-member
templated functions {}\texttt{set\-\_extra\-\_data<>(...)} and
{}\texttt{get\-\_extra\-\_data<>(...)} serve this purpose (see item
({}\ref{rcpqs:apdx:qs:extra-data}) in Appendix {}\ref{rcpqs:apdx:quickstart}).
Note that the extra data mechanism relies on an {}\texttt{std::map} and string
comparisons etc. and can impart some unacceptably high overhead in some use
cases.

\item \textbf{Embeddeding an object on creation of an RCP object}

Similar to the use of extra data, the RCP class also supports the concept of
an embedded object.  The functions
{}\texttt{rcp\-With\-Embedded\-Obj\-[PreDestroy,PostDestroy](...)} (see
{}\ref{rcpqs:apdx:qs:embedded-objects} in Appendix
{}\ref{rcpqs:apdx:quickstart}) can be used create an {}\texttt{RCP} object and
embedd any other value-type object in the created {}\texttt{RCPNode}.  This
uses a customized deallocator class and imparts less overhead than the extra
data feature at the cost of being less flexible (i.e.\ you can can only embedd
a single value object and it must be done right when the first {}\texttt{RCP}
object is created).  The advantage of this approach is that access of the
embedded object using the {}\texttt{get\-[Nonconst]\-Embedded\-Obj(...)} is
faster than when using extra data but requires that you provide more
information.

\item \textbf{Checking for memory leaks from circular references}

In a debug build, the user can enable checking for memory leaks caused by
circular references among RCP objects.  If cicular references do exist, then
RCPNode objects that where created but not removed are displaed at the end of
a program.  See the file {}\texttt{Teuchos\-\_RCP.cpp} for details.

\end{enumerate}

%
\section{Summary}
%

The templated C++ class {}\texttt{RCP} provides a
low-overhead option for (almost) automatic memory management in C++.
This class has been developed and refined over many years and has been
instrumental in improving the quality of software projects that use it
consistently (for example see MOOCHO {}\cite{ref:moochouserguide}).
Careful use of {}\texttt{RCP} eliminates the need to
manually call operator {}\texttt{delete} when dynamically allocated
objects are no longer needed.  Furthermore, it helps to reduce the
amount of code that developers have to write.  For example, most
classes that use {}\texttt{RCP} for dynamically
allocated memory do not need developer-supplied destructors.  This
because the compiler-generated destructors do the exactly correct
thing which is to call destructors on an object's constituent data
members.  This was demonstrated in the difference between the original
and refactored classes {}\texttt{ClientB} and {}\texttt{ClientC}
described in Sections {}\ref{rcpbg:sec:original-program} and
{}\ref{rcpbg:sec:refactored-program}.

The class {}\texttt{RCP} also has advanced features not
found in other smart-pointer implementations such as the ability to
attach extra data and the customization of the deallocation policy.

% ---------------------------------------------------------------------- %
% References
%
\clearpage
\bibliographystyle{plain}
\bibliography{references}
\addcontentsline{toc}{section}{References}

% ---------------------------------------------------------------------- %
% Appendices should be stand-alone for SAND reports. If there is only
% one appendix, put \setcounter{secnumdepth}{0} after \appendix
%

\appendix

%
\section{C++ declarations for {}\texttt{RCP}}
\label{rcpqs:apdx:c++decl}
%

{\scriptsize\begin{verbatim}
namespace Teuchos {

enum ENull { null };

enum EPrePostDestruction { PRE_DESTROY, POST_DESTROY };

template<class T>
class DeallocDelete { public: void free( T* ptr ) { if(ptr) delete ptr; }  };

template<class T>
class DeallocArrayDelete { public: void free( T* ptr ) { if(ptr) delete [] ptr; }  };

template<class T>
class RCP {
public:
  typedef T  element_type;
  explicit RCP( T* ptr, bool owns_mem = true );
  RCP( ENull null_arg = null );
  RCP(const RCP<T>& r_ptr);
  template<class T2> RCP(const RCP<T2>& r_ptr);
  ~RCP();
  RCP<T>& operator=(const RCP<T>& r_ptr);
  T* operator->() const;
  T& operator*() const;
  T* get() const;
  T* release();
  int count() const;
  void set_has_ownership();
  bool has_ownership() const;
  bool shares_resource(const RCP<T>& r_ptr) const;
private:
  ...
};

template<class T>            RCP<T>   rcp( T* p );
template<class T>            RCP<T>   rcp( T* p, bool owns_mem);
template<class T,
  class Dealloc_T>           RCP<T>   rcp( T* p, Dealloc_T dealloc, bool owns_mem );
template<class T,
  class Embedded>            RCP<T>   rcpWithEmbeddedObjPreDestroy( T* p,
                                       const Embedded &embedded, bool owns_mem = true );
template<class T,
  class Embedded>            RCP<T>   rcpWithEmbeddedObjPostDestroy( T* p,
                                        const Embedded &embedded, bool owns_mem = true );
template<class T,
  class Embedded>            RCP<T>   rcpWithEmbeddedObj( T* p,
                                        const Embedded &embedded, bool owns_mem = true );
template<class T>            bool     is_null(const RCP<T>& p);
template<class T>            bool     operator==(const RCP<T>& p, ENull);
template<class T>            bool     operator!=(const RCP<T>& p, ENull);
template<class T2, class T1> bool     operator==(const RCP<T1>& p1,
                                                 const RCP<T2>& p2 );
template<class T2, class T1> bool     operator!=(const RCP<T1>& p1,
                                                 const RCP<T2>& p2 );
\end{verbatim}}
\pagebreak
{\scriptsize\begin{verbatim}
template<class T2, class T1> RCP<T2>          rcp_implicit_cast(const RCP<T1>& p1);
template<class T2, class T1> RCP<T2>          rcp_static_cast(const RCP<T1>& p1);
template<class T2, class T1> RCP<T2>          rcp_const_cast(const RCP<T1>& p1);
template<class T2, class T1> RCP<T2>          rcp_dynamic_cast(const RCP<T1>& p1,
                                                       bool throw_on_fail = false );
template<class T1, class T2> int              set_extra_data( const T1 &extra_data,
                                                const std::string& name, const Ptr<RCP<T2> > &p,
                                                bool force_unique = true,
                                                EPrePostDestruction destroy_when = POST_DESTROY );
template<class T1, class T2> const T1&        get_extra_data( const RCP<T2>& p,
                                                const std::string& name );
template<class T1, class T2> T1&              get_nonconst_extra_data( const RCP<T2>& p,
                                                const std::string& name );
template<class T1, class T2> T1*              get_optional_extra_data( const RCP<T2>& p,
                                                const std::string& name );
template<class T1, class T2> const T1*        get_optional_extra_data( const RCP<T2>& p,
                                                const std::string& name );
template<class Dealloc_T,
  class T>                   const Dealloc_T& get_dealloc( const RCP<T>& p );
template<class Dealloc_T,
  class T>                   Dealloc_T&       get_nonconst_dealloc( const RCP<T>& p );
template<class Dealloc_T,
  class T>                   const Dealloc_T* get_optional_dealloc( const RCP<T>& p );
template<class Dealloc_T,
  class T>                   Dealloc_T*       get_optional_nonconst_dealloc( const RCP<T>& p );
template<class TOrig,
  class Embedded, class T>   const Embedded&  getEmbeddedObj( const RCP<T>& p );
template<class TOrig,
  class Embedded, class T>   Embedded&        getNonconstEmbeddedObj( const RCP<T>& p );


} // namespace Teuchos
\end{verbatim}}

%
\section{\texttt{RCP} quick-start and reference}
\label{rcpqs:apdx:quickstart}
%

This appendix presents a short, but fairly comprehensive, quick-start
for the use of {}\texttt{RCP}.  The use cases described
here should cover the overwhelming majority of the use instances of
{}\texttt{RCP} in a typical program.

The following class hierarchy will be used in the C++ examples given
below.

{\small\begin{verbatim}
class A { public: virtual ~A(){} A& operator=(const A&){} virtual void f(){} };
class B1 : virtual public A {};
class B2 : virtual public A {};
class C : virtual public B1, virtual public B2 {};

class D {};
class E : public D {};
\end{verbatim}}

All of the following code examples used in this appendix are assumed
to be in the namespace {}\texttt{Teuchos} or have appropriate
{}\texttt{using Teuchos::...} declarations.  This removes the need to
explicitly use {}\texttt{Teuchos::} to qualify classes, functions and
other declarations from the {}\texttt{Teuchos} namespace.  Note that
some of the runtime checks are denoted as ``debug runtime checked''
which means that checking will only be performed in a debug build
(that is one where the macro {}\texttt{\_DEBUG} is defined at compile time).

\begin{enumerate}

\item {\bf Creation of \texttt{RCP} objects}

\begin{enumerate}

\item {\bf Initializing a \texttt{RCP} object to NULL}
\label{rcpqs:apdx:qs:null}
%
{\small\begin{verbatim}
RCP<C> c_ptr;
\end{verbatim}}
or
{\small\begin{verbatim}
RCP<C> c_ptr = null;
\end{verbatim}}

\item {\bf Creating a \texttt{RCP} object using \texttt{new}}
\label{rcpqs:apdx:qs:new}
%
{\small\begin{verbatim}
RCP<C> c_ptr = rcp(new C);
\end{verbatim}}
or
{\small\begin{verbatim}
RCP<C> c_ptr(new C);
\end{verbatim}}
%
\item {\bf Creating a \texttt{RCP} object to an array allocated using \texttt{new[n]}} \\
\label{rcpqs:apdx:qs:array-new}
%
See the class {}\texttt{Teuchos::ArrayRCP}.
%
\item {\bf Initializing a \texttt{RCP} object to an object
       \underline{not} allocated with \texttt{new}}
\label{rcpqs:apdx:qs:not-new}
%
{\small\begin{verbatim}
C      c;
RCP<C> c_ptr = rcp(&c,false);
\end{verbatim}}
%
\item {\bf Copy constructor (implicit casting)}
%
{\small\begin{verbatim}
RCP<C>       c_ptr  = rcp(new C); // No cast
RCP<A>       a_ptr  = c_ptr;      // Cast to base class
RCP<const A> ca_ptr = a_ptr;      // Cast from non-const to const
\end{verbatim}}
%
\item {\bf Representing constantness and non-constantness}
%
\begin{enumerate}
%
\item {\bf Non-constant pointer to non-constant object }
{\small\begin{verbatim}
RCP<C> c_ptr;
\end{verbatim}}
%
\item {\bf Constant pointer to non-constant object }
{\small\begin{verbatim}
const RCP<C> c_ptr;
\end{verbatim}}
%
\item {\bf Non-Constant pointer to constant object }
{\small\begin{verbatim}
RCP<const C> c_ptr;
\end{verbatim}}
%
\item {\bf Constant pointer to constant object }
{\small\begin{verbatim}
const RCP<const C> c_ptr;
\end{verbatim}}
%
\end{enumerate}
%
\end{enumerate}

\item {\bf Reinitialization of \texttt{RCP} objects (using assignment operator)}
%
\begin{enumerate}
%
\item {\bf Resetting from a raw pointer}
%
{\small\begin{verbatim}
RCP<A> a_ptr;
a_ptr = rcp(new A());
\end{verbatim}}
%
\item {\bf Resetting to null}
%
{\small\begin{verbatim}
RCP<A> a_ptr = rcp(new A());
a_ptr = null; // The A object will be deleted here
\end{verbatim}}
%
\item {\bf Assigning from a \texttt{RCP} object}
%
{\small\begin{verbatim}
RCP<A> a_ptr1;
RCP<A> a_ptr2 = rcp(new A());
a_ptr1 = a_ptr2; // Now a_ptr1 and a_ptr2 point to same A object
\end{verbatim}}
%
\end{enumerate}

\item {\bf Accessing the reference-counted object}
%
\begin{enumerate}
%
\item {\bf Access to object reference (debug runtime checked)}
%
{\small\begin{verbatim}
C &c_ref = *c_ptr;
\end{verbatim}}
%
\item {\bf Access to object pointer (unchecked, may return \texttt{NULL}, NOT RECOMMENDED)}
%
{\small\begin{verbatim}
C *c_rptr = c_ptr.get();
\end{verbatim}}
%
\item {\bf Access to object pointer (debug runtime checked, will not return \texttt{NULL}, NOT RECOMMENDED)}
%
{\small\begin{verbatim}
C *c_rptr = &*c_ptr;
\end{verbatim}}
%
\item {\bf Access of object's member (debug runtime checked)}
%
{\small\begin{verbatim}
c_ptr->f();
\end{verbatim}}
%
\item {\bf Testing for non-null}
%
{\small\begin{verbatim}
if( !is_null(a_ptr) ) std::cout << "a_ptr is not null!\n";
\end{verbatim}}
%
or
%
{\small\begin{verbatim}
if( a_ptr != null ) std::cout << "a_ptr is not null!\n";
\end{verbatim}}
%
\item {\bf Testing for null}
%
{\small\begin{verbatim}
if( is_null(a_ptr) ) std::cout << "a_ptr is null!\n";
\end{verbatim}}
%
or
%
{\small\begin{verbatim}
if( a_ptr == null ) std::cout << "a_ptr is null!\n";
\end{verbatim}}

%
\end{enumerate}

\item {\bf Casting}
\label{rcpqs:apdx:qs:casting}
%
\begin{enumerate}
%
\item {\bf Implicit casting (see copy constructor above)}
%
\begin{enumerate}
%
\item {\bf Using copy constructor (see above)}
%
\item {\bf Using conversion function}
%
{\small\begin{verbatim}
RCP<C>       c_ptr  = rcp(new C);                       // No cast
RCP<A>       a_ptr  = rcp_implicit_cast<A>(c_ptr);      // To base
RCP<const A> ca_ptr = rcp_implicit_cast<const A>(a_ptr);// To const
\end{verbatim}}
%
\end{enumerate}
%
\item {\bf Casting away \texttt{const}}
%
{\small\begin{verbatim}
RCP<const A>  ca_ptr = rcp(new C);
RCP<A>        a_ptr  = rcp_const_cast<A>(ca_ptr); // cast away const!
\end{verbatim}}
%
\item {\bf Static cast (no runtime check)}
%
{\small\begin{verbatim}
RCP<D>  d_ptr = rcp(new E);
RCP<E>  e_ptr = rcp_static_cast<E>(d_ptr); // Unchecked, unsafe?
\end{verbatim}}
%
\item {\bf Dynamic cast (runtime checked, failed cast allowed)}
%
{\small\begin{verbatim}
RCP<A>  a_ptr  = rcp(new C);
RCP<B1> b1_ptr = rcp_dynamic_cast<B1>(a_ptr);  // Checked, safe!
RCP<B2> b2_ptr = rcp_dynamic_cast<B2>(b1_ptr); // Checked, safe!
RCP<C>  c_ptr  = rcp_dynamic_cast<C>(b2_ptr);  // Checked, safe!
\end{verbatim}}
%
\item {\bf Dynamic cast (runtime checked, failed cast not allowed)}
%
{\small\begin{verbatim}
RCP<A>  a_ptr1  = rcp(new C);
RCP<A>  a_ptr2  = rcp(new A);
RCP<B1> b1_ptr1 = rcp_dynamic_cast<B1>(a_ptr1,true); // Success!
RCP<B1> b1_ptr2 = rcp_dynamic_cast<B1>(a_ptr2,true); // Throw std::bad_cast!
\end{verbatim}}
%
\end{enumerate}

\pagebreak

\item {\bf Customized deallocators}
\label{rcpqs:apdx:qs:dealloc}
%
\begin{enumerate}
%
\item {\bf Creating a \texttt{RCP} object with a custom deallocator }
%
{\small\begin{verbatim}
RCP<C> c_ptr = rcp(new C[N],DeallocArrayDelete<C>(),true);
\end{verbatim}}
%
\item {\bf Access customized deallocator (runtime checked, throws on failure)}
%
{\small\begin{verbatim}
const DeallocArrayDelete<C>
  &dealloc = get_dealloc<DeallocArrayDelete<C> >(c_ptr);
\end{verbatim}}
%
\item {\bf Access optional customized deallocator}
%
{\small\begin{verbatim}
const DeallocArrayDelete<C>
  *dealloc = get_optional_dealloc<DeallocArrayDelete<C> >(c_ptr);
if(dealloc) std::cout << "This deallocator exits!\n";
\end{verbatim}}
%
\end{enumerate}

\item {\bf Managing extra data}
\label{rcpqs:apdx:qs:extra-data}
%
\begin{enumerate}
%
\item {\bf Adding extra data (post destruction of extra data)}
%
{\small\begin{verbatim}
set_extra_data(rcp(new B1),"A:B1",&a_ptr);
\end{verbatim}}
%
\item {\bf Adding extra data (pre destruction of extra data)}
%
{\small\begin{verbatim}
set_extra_data(rcp(new B1),"A:B1",&a_ptr,PRE_DESTORY);
\end{verbatim}}
%
\item {\bf Retrieving extra data}
%
{\small\begin{verbatim}
get_extra_data<RCP<B1> >(a_ptr,"A:B1")->f();
\end{verbatim}}
%
\item {\bf Resetting extra data}
%
{\small\begin{verbatim}
get_extra_data<RCP<B1> >(a_ptr,"A:B1") = rcp(new C);
\end{verbatim}}
%
\item {\bf Retrieving optional extra data}
%
{\small\begin{verbatim}
const RCP<B1> *b1 = get_optional_extra_data<RCP<B1> >(a_ptr,"A:B1");
if(b1) (*b1)->f();
\end{verbatim}}
%
\end{enumerate}

\item {\bf Embedded objects}
\label{rcpqs:apdx:qs:embedded-objects}

%
\begin{enumerate}
%
\item {\bf Creating an RCP object with embedded data}
%
{\small\begin{verbatim}
RCP<D> d_ptr(new D);
RCP<A> a_ptr rcpWithEmbeddedObj(new C, rcp(new D));
\end{verbatim}}
%
\item {\bf Extract reference to const embedded object}
%
{\small\begin{verbatim}
const RCP<D> &d_ptr = getEmbeddedObj<C,RCP<D> >(a_ptr);
\end{verbatim}}
%
\item {\bf Extract reference to nonconst embedded object}
%
{\small\begin{verbatim}
RCP<D> &d_ptr = getNonconstEmbeddedObj<C,RCP<D> >(a_ptr);
d_ptr = null; // Sets the actual embedded RCP<D> object in a_ptr to null!
\end{verbatim}}
%
\end{enumerate}


\end{enumerate}

%
\section{Commandments for the use of {}\texttt{RCP}}
\label{rcpqs:apdx:commandments}
%

Here are listed commandments for the use of {}\texttt{RCP}.  These
commandments reinforce some of the material in the quick-start in Appendix
{}\ref{rcpqs:apdx:quickstart}.  Along with each commandment is one or more
anti-commandments stating the negative of the commandment.  C++ code fragments
are also included to demonstrate each commandment and anti-commandment.

\begin{commandment}\label{rcp:cmd:rcp-new}
Thou shall put a pointer for an object allocated with operator
{}\texttt{new} into a {}\texttt{RCP} object only once.
The best way to insure this is to call operator {}\texttt{new}
directly in a call to {}\texttt{rcp(...)} to create a dynamically
allocated object that is to be managed by a
{}\texttt{RCP} object.  See item
({}\ref{rcpqs:apdx:qs:new}) in Appendix
{}\ref{rcpqs:apdx:quickstart}.
\end{commandment}

\begin{anticommandment}
Thou shall never give a raw C++ pointer returned from operator
{}\texttt{new} to more than one {}\texttt{RCP} object.
\end{anticommandment}

{}\noindent{}Example:
{\small\begin{verbatim}
  A *ra_ptr = new C;
  RCP<A> a_ptr1 = rcp(ra_ptr); // Okay
  RCP<A> a_ptr2 = rcp(ra_ptr); // no, No, NO !!!!
\end{verbatim}}

\begin{anticommandment}
Thou shall never give a raw C++ pointer to an array of objects
returned from operator {}\texttt{new[]} to a
{}\texttt{RCP} object using {}\texttt{rcp(new C[n])}.
\end{anticommandment}

{}\noindent{}Example:
{\small\begin{verbatim}
  RCP<std::vector<C> > c_array_ptr1 = rcp(new std::vector<C>(N)); // Okay
  RCP<C>               c_array_ptr3 = rcp(new C[n]);              // no, No, NO!
\end{verbatim}}

\begin{commandment}
Thou shall only create a {}\texttt{NULL} {}\texttt{RCP}
object by using the default constructor or by using the
{}\texttt{null} enum (and its associated special constructor) (see
item ({}\ref{rcpqs:apdx:qs:null}) in Appendix
{}\ref{rcpqs:apdx:quickstart}).  Trying to assign to {}\texttt{NULL}
or {}\texttt{0} will not compile.
\end{commandment}

\begin{anticommandment}
Thou shall not create a {}\texttt{NULL} {}\texttt{RCP}
object using the templated function {}\texttt{rcp(...)} since it is
very verbose and complicates maintenance.
\end{anticommandment}

{}\noindent{}Example:
{\small\begin{verbatim}
  RCP<A> a_ptr1 = null;          // Yes :-)
  RCP<A> a_ptr2 = rcp<A>(NULL);  // No, too verbose :-(
\end{verbatim}}

\begin{commandment}
Thou shall only pass a raw pointer for an object that is
{}\underline{not} allocated by operator {}\texttt{new} (e.g.~allocated
on the stack) into a {}\texttt{RCP} object by using the
templated function {}\texttt{rcp<T>(T* p, bool owns\_mem)} and setting
{}\texttt{owns\_mem} to {}\texttt{false} (see item
({}\ref{rcpqs:apdx:qs:not-new}) in Appendix
{}\ref{rcpqs:apdx:quickstart}).
\end{commandment}

\begin{anticommandment}
Thou shall never pass a pointer for an object {}\underline{not}
allocated with operator {}\texttt{new} into a
{}\texttt{RCP} object without setting
{}\texttt{owns\_mem} to {}\texttt{false}.
\end{anticommandment}

{}\noindent{}Example:
{\small\begin{verbatim}
  C c;
  RCP<A> a_ptr1 = rcp(&c,false);  // Yes :-)
  RCP<A> a_ptr2 = rcp(&c);        // no, No, NO !!!!
\end{verbatim}}

\begin{commandment}\label{rcp:cmnd:converstion}
Thou shall only cast between {}\texttt{RCP} objects
using the default copy constructor (for implicit conversions) and the
nonmember template functions {}\texttt{rcp\-\_implicit\-\_cast<>(\-...)},
{}\texttt{rcp\-\_static\-\_cast<>(\-...)},
{}\texttt{rcp\-\_const\-\_cast<>(\-...)} and
{}\texttt{rcp\-\_dynamic\-\_cast<>(\-...)}  (see item
({}\ref{rcpqs:apdx:qs:casting}) in Appendix
{}\ref{rcpqs:apdx:quickstart}).
\end{commandment}

\begin{anticommandment}
Thou shall never convert between {}\texttt{RCP} objects
using raw pointer access.
\end{anticommandment}

{}\noindent{}Example:
{\small\begin{verbatim}
  RCP<A>     a_ptr   = rcp(new C);
  RCP<B1>    b1_ptr1 = rcp_dynamic_cast<B1>(a_ptr);         // Yes :-)
  RCP<B1>    b1_ptr2 = rcp(dynamic_cast<B1*>(a_ptr.get())); // no, No, NO !!!
\end{verbatim}}

%
\section{Recommendations for passing objects to and from C++ functions}
\label{rcpqs:apdx:passing-args}
%

Below are recommended idioms for passing required\footnote{Required arguments
must be bound to valid objects (i.e.~can not be {}\texttt{NULL})} and
optional\footnote{Optional arguments may be {}\texttt{NULL} in some cases}
arguments into and out of C++ functions for various use cases and different
types of objects.  These idioms show how to write function prototype argument
declarations which exploit the C++ language in a way that makes these function
prototypes as self documenting as possible, avoids coding errors, and
increases readability\footnote{What makes code more ``readable'' is subjective
of course.} of C++ code.  In general, {}\texttt{RCP<T>} objects should be
passed and manipulated as though they where raw C++ pointer {}\texttt{T*}
objects.  However, while raw C++ pointer objects should generally be passed by
value, {}\texttt{RCP} objects should generally be passed by reference for
several reasons.

%
%\fbox{
\begin{center}
\begin{minipage}{{}\textwidth}
\begin{tabular}{|l|l|l|}
\hline
Argument purpose
& Non-Persisting
& Persisting \\
\hline
\hline
non-changeable object (required$^1$)
& \begin{minipage}{12ex}
    {\tiny .}\\
    {}\texttt{S s} \\
    or \\
    {}\texttt{const S s} \\
    or \\
    {}\texttt{const S \&s} \\
    %{\tiny .}
  \end{minipage}
& {}\texttt{const RCP<const S> \&s} \\
\hline
non-changeable object (optional$^2$)
& {}\texttt{const Ptr<const S> \&s}
& {}\texttt{const RCP<const S> \&s} \\
\hline
changeable object
& {}\texttt{const Ptr<S> \&s}
& {}\texttt{const RCP<S> \&s} \\
\hline
\end{tabular}\\[2ex]
C++ declarations for passing small concrete objects (i.e.~with value
semantics) to and from functions where {}\texttt{S} is a place holder for an
actual built-in or user-defined data type.
\end{minipage}
\end{center}
%} % end fbox
%
%\\[5ex]
%
%\fbox{
\begin{center}
\begin{minipage}{{}\textwidth}
\begin{tabular}{|l|l|l|}
\hline
Argument purpose
& Non-Persisting
& Persisting \\
\hline
\hline
non-changeable object (required$^1$)
& {}\texttt{const A \&a}
& {}\texttt{const RCP<const A> \&a} \\
\hline
non-changeable object (optional$^2$)
& {}\texttt{const Ptr<const A> \&a}
& {}\texttt{const RCP<const A> \&a} \\
\hline
changeable object
& {}\texttt{const Ptr<A> \&a}
& {}\texttt{const RCP<A> \&a} \\
\hline
\end{tabular}\\[2ex]
C++ declarations for passing abstract objects (i.e.\ with reference or pointer
semantics) or large concrete objects (i.e.\ that are too expensive to copy) to
and from functions where {}\texttt{A} is a place holder for an actual abstract
C++ base class.
\end{minipage}
\end{center}
%} % end fbox

%
\section{Listing: Example C++ program using raw dynamic memory management}
\label{rcpqs:apdx:ex-prg}
%

{\small\begin{verbatim}
#include "example_get_args.hpp"

// Abstract interfaces
class UtilityBase {
public:
  virtual void f() const = 0;
};
class UtilityBaseFactory {
public:
  virtual UtilityBase* createUtility() const = 0;
};

// Concrete implementations
class UtilityA : public UtilityBase {
public:
  void f() const { std::cout<<"\nUtilityA::f() called, this="<<this<<"\n"; }
};
class UtilityB : public UtilityBase {
public:
  void f() const { std::cout<<"\nUtilityB::f() called, this="<<this<<"\n"; }
};
class UtilityAFactory : public UtilityBaseFactory {
public:
  UtilityBase* createUtility() const { return new UtilityA(); }
};
class UtilityBFactory : public UtilityBaseFactory {
public:
  UtilityBase* createUtility() const { return new UtilityB(); }
};

// Client classes
class ClientA {
public:
  void f( const UtilityBase &utility ) const { utility.f(); }
};
class ClientB {
  UtilityBase *utility_;
public:
  ClientB() : utility_(0) {}
  ~ClientB() { delete utility_; }
  void initialize( UtilityBase *utility ) { utility_ = utility; }
  void g( const ClientA &a ) { a.f(*utility_); }
};
class ClientC {
  const UtilityBaseFactory *utilityFactory_;
  UtilityBase *utility_;
  bool shareUtility_;
public:
  ClientC( const UtilityBaseFactory *utilityFactory, bool shareUtility )
    :utilityFactory_(utilityFactory)
    ,utility_(utilityFactory->createUtility())
    ,shareUtility_(shareUtility) {}
  ~ClientC() { delete utilityFactory_; delete utility_; }
  void h( ClientB *b ) {
    if( shareUtility_ ) b->initialize(utility_);
    else b->initialize(utilityFactory_->createUtility());
  }
};

// Main program
int main( int argc, char* argv[] )
{
  // Read options from the commandline
  bool useA, shareUtility;
  example_get_args(argc,argv,&useA,&shareUtility);
  // Create factory
  UtilityBaseFactory *utilityFactory = 0;
  if(useA) utilityFactory = new UtilityAFactory();
  else     utilityFactory = new UtilityBFactory();
  // Create clients
  ClientA a;
  ClientB b1, b2;
  ClientC c(utilityFactory,shareUtility);
  // Do some stuff
  c.h(&b1);
  c.h(&b2);
  b1.g(a);
  b2.g(a);
  // Cleanup memory
  delete utilityFactory;
}
\end{verbatim}}

%
\section{Listing: Refactored example C++ program using {}\texttt{RCP}}
\label{rcpqs:apdx:ex-prg-refactored}
%

{\small\begin{verbatim}
#include "Teuchos_RCP.hpp"
#include "example_get_args.hpp"

// Inject symbols for RCP so we don't need Teuchos:: qualification
using Teuchos::RCP;
using Teuchos::rcp; // Warning! This can be dangerous and is not to be used in general!
using Teuchos::Ptr;

// Abstract interfaces
class UtilityBase {
public:
  virtual void f() const = 0;
};
class UtilityBaseFactory {
public:
  virtual RCP<UtilityBase> createUtility() const = 0;
};

// Concrete implementations
class UtilityA : public UtilityBase {
public:
  void f() const { std::cout<<"\nUtilityA::f() called, this="<<this<<"\n"; }
};
class UtilityB : public UtilityBase {
public:
  void f() const { std::cout<<"\nUtilityB::f() called, this="<<this<<"\n"; }
};
class UtilityAFactory : public UtilityBaseFactory {
public:
  RCP<UtilityBase> createUtility() const { return rcp(new UtilityA()); }
};
class UtilityBFactory : public UtilityBaseFactory {
public:
  RCP<UtilityBase> createUtility() const { return rcp(new UtilityB()); }
};

// Client classes
class ClientA {
public:
  void f( const UtilityBase &utility ) const { utility.f(); }
};
class ClientB {
  RCP<UtilityBase> utility_;
public:
  void initialize(const RCP<UtilityBase> &utility) { utility_=utility; }
  void g( const ClientA &a ) { a.f(*utility_); }
};
class ClientC {
  RCP<const UtilityBaseFactory> utilityFactory_;
  RCP<UtilityBase> utility_;
  bool shareUtility_;
public:
  ClientC( const RCP<const UtilityBaseFactory> &utilityFactory, bool shareUtility )
    :utilityFactory_(utilityFactory)
    ,utility_(utilityFactory->createUtility())
    ,shareUtility_(shareUtility) {}
  void h( const Ptr<ClientB> &b ) {
    if( shareUtility_ ) b->initialize(utility_);
    else b->initialize(utilityFactory_->createUtility());
  }
};

// Main program
int main( int argc, char* argv[] )
{
  // Read options from the commandline
  bool useA, shareUtility;
  example_get_args(argc,argv,&useA,&shareUtility);
  // Create factory
  RCP<UtilityBaseFactory> utilityFactory;
  if(useA) utilityFactory = rcp(new UtilityAFactory());
  else     utilityFactory = rcp(new UtilityBFactory());
  // Create clients
  ClientA a;
  ClientB b1, b2;
  ClientC c(utilityFactory,shareUtility);
  // Do some stuff
  c.h(&b1);
  c.h(&b2);
  b1.g(a);
  b2.g(a);
}
\end{verbatim}}

%
% The Glossary
%

%\begin{theglossary}
%\entry{non-persisting relationship}
%A relationship that exits between two objects only during the
%execution of a function.
%\entry{persisting relationship}
%A relationship that exits between two objects that spans
%two or more function calls and may linger until the destruction
%of one or more of the related objects.
%\end{theglossary}

%
%\begin{SANDdistribution}
%\end{SANDdistribution}

\end{document}
