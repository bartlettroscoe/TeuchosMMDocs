\documentclass[pdf,ps2pdf,11pt]{SANDreport}
\usepackage{pslatex}

%Local stuff
\usepackage{graphicx}
\usepackage{latexsym}
\input{rab_commands}

\newtheorem{commandment}{Commandment}
\newtheorem{anticommandment}{Anti-Commandment}

% If you want to relax some of the SAND98-0730 requirements, use the "relax"
% option. It adds spaces and boldface in the table of contents, and does not
% force the page layout sizes.
% e.g. \documentclass[relax,12pt]{SANDreport}
%
% You can also use the "strict" option, which applies even more of the
% SAND98-0730 guidelines. It gets rid of section numbers which are often
% useful; e.g. \documentclass[strict]{SANDreport}

% ---------------------------------------------------------------------------- %
%
% Set the title, author, and date
%

\title{\center
{\Huge\bf Teuchos::RefCountPtr Beginner's Guide}\\[1.5ex]
An Introduction to the Trilinos Smart Reference-Counted Pointer
Class for (Almost) Automatic Dynamic Memory Management in C++
}
\author{
Roscoe A. Bartlett \\ Optimization and Uncertainty Estimation \\
Sandia National Laboratories\footnote{
Sandia is a multiprogram laboratory operated by Sandia Corporation, a
Lockheed-Martin Company, for the United States Department of Energy
under Contract DE-AC04-94AL85000.}, Albuquerque NM 87185 USA, \\
}
\date{}

% ---------------------------------------------------------------------------- %
% Set some things we need for SAND reports. These are mandatory
%
\SANDnum{SAND2004-3268}
\SANDprintDate{June 2004}
\SANDauthor{
Roscoe A. Bartlett \\ Optimization and Uncertainty Estimation
}

% ---------------------------------------------------------------------------- %
% The following definitions are optional. The values shown are the default
% ones provided by SANDreport.cls
%
\SANDreleaseType{Unlimited Release}
%\SANDreleaseType{Not approved for release outside Sandia}

% ---------------------------------------------------------------------------- %
% The following definition does not have a default value and will not
% print anything, if not defined
%
%\SANDsupersed{SAND1901-0001}{January 1901}

% ---------------------------------------------------------------------------- %
%
% Start the document
%
\begin{document}

\maketitle

% ------------------------------------------------------------------------ %
% An Abstract is required for SAND reports
%

%
\begin{abstract}
%
Dynamic memory management in C++ is one of the most common areas of
difficulty and errors for amateur and expert C++ developers alike.
The improper use of operator {}\texttt{new} and operator
{}\texttt{delete} is arguably the most common cause of incorrect
program behavior and segmentation faults in C++ programs.  Here we
introduce a templated concrete C++ class
{}\texttt{Teuchos\-::Ref\-Count\-Ptr<>}, which is part of the Trilinos
tools package {}\texttt{Teuchos}, that combines the concepts of smart
pointers and reference counting to build a low-overhead but effective
tool for simplifying dynamic memory management in C++.  We discuss why
the use of raw pointers for memory management, managed through
explicit calls to operator {}\texttt{new} and operator
{}\texttt{delete}, is so difficult to accomplish without making
mistakes and how programs that use raw pointers for memory management
can easily be modified to use {}\texttt{Ref\-Count\-Ptr<>}.  In
addition, explicit calls to operator {}\texttt{delete} is fragile and
results in memory leaks in the presents of C++ exceptions.  In its
most basic usage, {}\texttt{Ref\-Count\-Ptr<>} automatically
determines when operator {}\texttt{delete} should be called to free an
object allocated with operator {}\texttt{new} and is not fragile in
the presents of exceptions.  The class also supports more
sophisticated use cases as well.  This document describes just the
most basic usage of {}\texttt{Ref\-Count\-Ptr<>} to allow developers
to get started using it right away.  However, more detailed
information on the design and advanced features of
{}\texttt{Ref\-Count\-Ptr<>} is provided by the companion document
``Teuchos::RefCountPtr : The Trilinos Smart Reference-Counted Pointer
Class for (Almost) Automatic Dynamic Memory Management in C++''
{}\cite{ref:RefCountPtr}.
%
\end{abstract}
%

% ------------------------------------------------------------------------ %
% An Acknowledgement section is optional but important, if someone made
% contributions or helped beyond the normal part of a work assignment.
% Use \section* since we don't want it in the table of context
%
\clearpage
\section*{Acknowledgments}

The author would like to thank Carl Laird, Heidi Thornquist, Mike
Heroux and Marzio Sala for comments on earlier drafts of this
document.

The format of this report is based on information found
in~\cite{Sand98-0730}.

% ------------------------------------------------------------------------ %
% The table of contents and list of figures and tables
% Comment out \listoffigures and \listoftables if there are no
% figures or tables. Make sure this starts on an odd numbered page
%
\clearpage
\tableofcontents
%\listoffigures
%\listoftables

% ---------------------------------------------------------------------- %
% This is where the body of the report begins; usually with an Introduction
%
\SANDmain % Start the main part of the report

%
\section{Introduction}
%

The main purpose of this document is to provide a quick-start guide on
how to incorporate the reference-counting smart pointer class
{}\texttt{Teuchos\-::Ref\-Count\-Ptr<>} into C++ programs that use
dynamic memory allocation and object orientation.  This code is
included in the Trilinos {}\cite{ref:Trilinos-Overview} tools package
{}\texttt{Teuchos}.  The design of
{}\texttt{Teuchos\-::Ref\-Count\-Ptr<>} is based partly on the
interface for {}\texttt{std\-::auto\-\_ptr<>} and Items 28 and 29 in
"More Effective C++" {}\cite{ref:meyers_1996}.  In short,
{}\texttt{Ref\-Count\-Ptr<>} allows one client to dynamically create
an object (using operator {}\texttt{new} for instance), pass the
object around to other clients that need to access the object and
never require any client to explicitly call operator
{}\texttt{delete}.  The object will (almost magically) be deleted when
all of the clients remove their references to the object.  In
principle, this is very similar to the type of garbage collection that
is in languages like Perl and Java.  There are some pathological cases
(such as the classic problem of circular references, see {}\cite[Item
29, page 212]{ref:meyers_1996}) where {}\texttt{Ref\-Count\-Ptr<>}
will result in a memory leak, but these situations can be avoided
through the careful use of {}\texttt{Ref\-Count\-Ptr<>}.  However,
realizing the potential of hands-off garbage collection with
{}\texttt{Ref\-Count\-Ptr<>} requires following some rules.  These
rules are partially spelled out in the form of commandments in
Appendix {}\ref{rcpqs:apdx:commandments}.

Note that direct calls to operator {}\texttt{delete} are discouraged
in modern C++ programs that are designed to be robust in the presence
of C++ exception handing.  This is because the raw use of operator
{}\texttt{delete} often results in memory leaks when exceptions are
thrown.  For example, in the code fragment:

{\small\begin{verbatim}
void someFunction() {
  A *a = new A;
  a->f();
  delete a;
}
\end{verbatim}}

{}\noindent{}if an exception is thrown in the function call
{}\texttt{a->f()} then the statement {}\texttt{delete a} will never be
executed and a memory leak will have been created.  The class
{}\texttt{std::auto\_\-ptr<>} was added to the standard C++ library
(see {}\cite[Items 9 and 10]{ref:meyers_1996}) to protect against
these types of memory leaks.  For example, the rewritten function:

{\small\begin{verbatim}
void someFunction() {
  std::auto_ptr<A> a(new A);
  a->f();
}
\end{verbatim}}

{}\noindent{}is robust in the event of exceptions and no memory leak
will occur.  However, {}\texttt{std::auto\_\-ptr<>} can not be used to
share a resource between two or more clients and therefore is not an
answer to the issue of general garbage collection.  The class
{}\texttt{Ref\-Count\-Ptr<>} not only is robust in the event of
exceptions but also implements reference counting and is therefore
more general (but admittedly more complex and expensive) than
{}\texttt{std::auto\_\-ptr<>}.

The use of {}\texttt{Ref\-Count\-Ptr<>} is critically important in the
development and maintenance of large complex object-oriented programs
composed of many separately-developed pieces (such as Trilinos).  This
discussion assumes that the reader has a basic familiarity and some
programming experience with C++ and has at least been exposed to the
basic concepts of object-oriented programming (good sources include
{}\cite{ref:gama_et_al_1995} and {}\cite{ref:stroustrup_2000}).
Furthermore, the reader should be comfortable with the use of C++
pointers and references.

The appendices contain basic reference material for
{}\texttt{Ref\-Count\-Ptr<>}.  In many respects, the appendices are
the most important contribution of this document.  For those readers
that like to see the C++ declarations right away, Appendix
{}\ref{rcpqs:apdx:c++decl} contains the C++ declarations for the
template class {}\texttt{Ref\-Count\-Ptr<>} and some important
associated non-member templated functions.  Appendix
{}\ref{rcpqs:apdx:quickstart} is a short reference-card-like
quick-start for the use of {}\texttt{Ref\-Count\-Ptr<>}.  The
quick-start in this appendix shows how to create
{}\texttt{Ref\-Count\-Ptr<>} objects from raw C++ pointers, how to
represent different forms on constantness, cast from one pointer type
to another, access the underlying reference-counted object as well as
to associate and manage extra data.  Appendix
{}\ref{rcpqs:apdx:commandments} gives some commandments for the use of
{}\texttt{Ref\-Count\-Ptr<>} and reinforces the material in Appendix
{}\ref{rcpqs:apdx:quickstart}.  Appendix
{}\ref{rcpqs:apdx:passing-args} gives tables of recommended idioms for
how to pass raw C++ objects and {}\texttt{Ref\-Count\-Ptr<>}-wrapped
objects to and from functions.  More detailed discussions of all of
the material in the appendices is contained in the design document for
{}\texttt{Ref\-Count\-Ptr<>} {}\cite{ref:RefCountPtr}.  Appendix
{}\ref{rcpqs:apdx:ex-prg} gives a listing for an example program that
uses raw pointer variables and direct calls to operator {}\texttt{new}
and operator {}\texttt{delete} while Appendix
{}\ref{rcpqs:apdx:ex-prg-refactored} shows a refactoring of this
example program to use {}\texttt{Ref\-Count\-Ptr<>}.

{}\textbf{Note!}  Anxious readers are encouraged to jump directly to
Appendix {}\ref{rcpqs:apdx:ex-prg} and
{}\ref{rcpqs:apdx:ex-prg-refactored} to get an idea of what
{}\texttt{Ref\-Count\-Ptr<>} is all about.  This example, together
with the reference material in the appendices, should be enough for
semi-experienced C++ developers to start using
{}\texttt{Ref\-Count\-Ptr<>} right away.

For less anxious readers, in the following section, we describe why
the use of raw C++ pointers and raw calls to operator {}\texttt{new}
and especially operator {}\texttt{delete} is difficult to program
correctly in even moderately complex C++ programs.  We then discuss
the different ways C++ pointers are used in such programs and describe
how to refactor these programs to replace some of the raw C++ pointers
and raw calls to operator {}\texttt{delete} with
{}\texttt{Ref\-Count\-Ptr<>}.  In the following discussion we will
define {}\textit{persisting} and {}\textit{non-persisting}
associations and will make a distinction between them (see page
{}\pageref{rcp:non-persisting-defined}).  {}\texttt{Ref\-Count\-Ptr<>}
is recommended for use only with {}\textit{persisting} associations.
The consistent use of {}\texttt{Ref\-Count\-Ptr<>} extends the
vocabulary of C++ in helping to distinguish between these two types of
relationships.  In addition, {}\texttt{Ref\-Count\-Ptr<>} is designed
for the memory management of individual objects, not raw C++ arrays of
objects.  Array allocation and deallocation should be performed using
standard C++ containers such as {}\texttt{std\-::vector<>},
{}\texttt{std\-::valarray<>} or some other such convenient C++ array
class.  However, it is quite common to dynamically allocate arrays of
{}\texttt{Ref\-Count\-Ptr<>} objects and use
{}\texttt{Ref\-Count\-Ptr<>} to manage the lifetime of such array
class objects.

%
\section{An example C++ program}
%

The use of object-oriented (OO) programing in C++ is the major
motivation for the development of {}\texttt{Ref\-Count\-Ptr<>}.  OO
programs are characterized by the use of abstract classes
(i.e.~interfaces) and concrete subclasses (i.e.~implementations).  In
OO programs it is common that the selection of which concrete
subclass(es) to use is not known until runtime.  The ``Abstract
Factory'' {}\cite{ref:gama_et_al_1995} is a popular design pattern
that allows the flexible runtime selection of what concrete subclasses
to create.

Below we describe a fictitious program that demonstrates some of the
typical features of an OO program that uses dynamic memory management
in C++.  In this simple program, handling memory management using raw
C++ pointers and calls to operator {}\texttt{new} and operator
{}\texttt{delete} will appear fairly easy but larger more realistic OO
programs are much more complicated and it is definitely not easy to do
memory management without some help.

%
\subsection{Example C++ program using raw dynamic memory management}
\label{rcpbg:sec:original-program}
%

One of the predominate features of this example program is the use of
the following abstract interface base class {}\texttt{Utility\-Base}
that defines an interface to provide some useful capability.

{\small\begin{verbatim}
class UtilityBase {
public:
  virtual void f() const = 0;
};
\end{verbatim}}

In our example program, {}\texttt{Utility\-Base} will have two
subclasses where one or the other will be used at runtime.

{\small\begin{verbatim}
class UtilityA : public UtilityBase {
public:
  void f() const { std::cout<<"\nUtilityA::f() called, this="<<this<<"\n"; }
};

class UtilityB : public UtilityBase {
public:
  void f() const { std::cout<<"\nUtilityB::f() called, this="<<this<<"\n"; }
};
\end{verbatim}}

{}\noindent{}In this example program the above implementation
functions just print to standard out.

Some of the clients in this program have to create
{}\texttt{Utility\-Base} objects without knowing exactly what concrete
subclasses are being used.  This is accomplished through the use of
the ``Abstract Factory'' design pattern {}\cite{ref:gama_et_al_1995}.
For {}\texttt{Utility\-Base}, the abstract factory looks like

{\small\begin{verbatim}
class UtilityBaseFactory {
public:
  virtual UtilityBase* createUtility() const = 0;
};
\end{verbatim}}

{}\noindent{}and has the following factory subclasses for creating
{}\texttt{Utility\-A} and {}\texttt{Utility\-B} objects.

{\small\begin{verbatim}
class UtilityAFactory : public UtilityBaseFactory {
public:
  UtilityBase* createUtility() const { return new UtilityA(); }
};

class UtilityBFactory : public UtilityBaseFactory {
public:
  UtilityBase* createUtility() const { return new UtilityB(); }
};
\end{verbatim}}

Now let's assume that our example program has the following client
classes.

{\small\begin{verbatim}
// Simple client with no state
class ClientA {
public:
  void f( const UtilityBase &utility ) const { utility.f(); }
};

// Client that maintains a pointer to a Utility object 
class ClientB {
  UtilityBase *utility_;
public:
  ClientB() : utility_(0) {}
  ~ClientB() { delete utility_; }
  void initialize( UtilityBase *utility ) { utility_ = utility; }
  void g( const ClientA &a ) { a.f(*utility_); }
};

// Client that maintains pointers to UtilityFactory and Utility objects
class ClientC {
  const UtilityBaseFactory *utilityFactory_;
  UtilityBase              *utility_;
  bool                     shareUtility_;
public:
  ClientC( const UtilityBaseFactory *utilityFactory, bool shareUtility )
    :utilityFactory_(utilityFactory)
    ,utility_(utilityFactory->createUtility())
    ,shareUtility_(shareUtility) {}
  ~ClientC() { delete utilityFactory_; delete utility_; }
  void h( ClientB *b ) {
    if( shareUtility_ ) b->initialize(utility_);
    else                b->initialize(utilityFactory_->createUtility());
  }
};
\end{verbatim}}

The type of logic used in {}\texttt{ClientC} for determining when new
objects should be created or when objects should be reused and passed
around is common in larger more complicated OO programs.

The above client classes demonstrate two different types of
associations between objects: {}\textit{non-persisting} and
{}\textit{persisting}.

{}\textit{Non-Persisting}\label{rcp:non-persisting-defined}
associations exist only within a single function call and do not
extend after the function has finished executing.  For example,
objects of type {}\texttt{Client\-A} and {}\texttt{Utility\-Base} have
a non-persisting relationship through the function
{}\texttt{ClientA\-::f(const UtilityBase \&utility)}.  Likewise,
objects of type {}\texttt{Client\-B} and {}\texttt{Client\-A} have a
non-persisting association through the function
{}\texttt{ClientB\-::g( const ClientA
\&a )}.

{}\textit{Persisting}\label{rcp:persisting-defined} associations are
where a relationship between two objects exists past a single function
call.  The most typical kind of persisting association in an OO C++
program is where one object maintains a private pointer data member to
another object.  For example, persisting associations exist between a
{}\texttt{ClientC} object, a {}\texttt{Utility\-Base\-Factory} and a
{}\texttt{Utility\-Base} object through the the private C++ pointer
data members {}\texttt{ClientC\-::utility\-Factory\_} and
{}\texttt{ClientC\-::utility\_} respectively.  Likewise, a persisting
association exists between a {}\texttt{ClientB} object and a
{}\texttt{Utility\-Base} object through the private pointer data
member {}\texttt{ClientB\-::utility\_}.

Persisting relationships are significantly more complex than
non-persisting relationships since a persisting relationship usually
implies that some objects must be responsible for the lifetime of
other objects.  This is never the case in a non-persisting relationship as
defined above.

Appendix {}\ref{rcpqs:apdx:ex-prg} shows an example program that uses
all of the C++ classes described above.  The program in Appendix
{}\ref{rcpqs:apdx:ex-prg} has several memory management problems. An
astute reader will notice that the {}\texttt{Utility\-Base\-Factory}
created in {}\texttt{main()} gets deleted twice; once in the
destructor for the {}\texttt{ClientC} object {}\texttt{c} and again at
the end of {}\texttt{main()} in an explicit call to operator
{}\texttt{delete}.  This problem could be fixed in this program by
arbitrating ``ownership'' of the {}\texttt{Utility\-Base\-Factory}
object to either {}\texttt{main()} or the {}\texttt{ClientC} object,
but not both which is the case in Appendix {}\ref{rcpqs:apdx:ex-prg}.

A more difficult memory management problem to catch and fix occurs in
the {}\texttt{ClientB} and {}\texttt{ClientC} objects regrading a
shared {}\texttt{Utility\-Base} object.  When {}\texttt{shareUtility}
is set to {}\texttt{false} (by the user in the commandline arguments)
the objects {}\texttt{b1}, {}\texttt{b2} and {}\texttt{c} each own a
pointer to different {}\texttt{Utility\-Base} objects and the software
will correctly delete each dynamically allocated object using one and
only one call to operator {}\texttt{delete} (in the destructors of
these classes).  However, when {}\texttt{shareUtility} is to set to
{}\texttt{true} the objects {}\texttt{b1}, {}\texttt{b2} and
{}\texttt{c} will contain pointers to the same
{}\texttt{Utility\-Base} object and operator {}\texttt{delete} will be
called on this shared {}\texttt{Utility\-Base} object multiple times
when {}\texttt{b1}, {}\texttt{b2} and {}\texttt{c} are destroyed.  In
this case, it is not so easy to arbitrate ownership of the shared
{}\texttt{Utility\-Base} object to the {}\texttt{ClientB} or the
{}\texttt{ClientC} objects.  Logic could be developed in this simple
program to insure that ownership was assigned properly but such logic
would enlarge the program, complicate maintenance, and would
ultimately make the software components less reusable.  In more
complex programs, trying to dynamically arbitrate ownership at run
time is much more difficult and error prone if done manually.

%
\subsection{Refactored example C++ program using {}\texttt{Ref\-Count\-Ptr<>}}
\label{rcpbg:sec:refactored-program}
%

Now we describe how {}\texttt{Ref\-Count\-Ptr<>} can be used to
greatly simplify dynamic memory management in these types of OO
programs.  Appendix {}\ref{rcpqs:apdx:ex-prg-refactored} shows the
refactoring of the program in Appendix {}\ref{rcpqs:apdx:ex-prg} to
use {}\texttt{Ref\-Count\-Ptr<>} for all persisting relationships.
In general, refactoring software that uses raw C++ pointers to use
{}\texttt{Ref\-Count\-Ptr<>} is as simple as replacing the type
{}\texttt{T*} with {}\texttt{Ref\-Count\-Ptr<T>}, where {}\texttt{T}
is nearly any class or built-in data type.

The first persisting relationship for which
{}\texttt{Ref\-Count\-Ptr<>} is used is the relationship between a
{}\texttt{Utility\-Base\-Factory} object and a client that uses it.
The refactoring changes the return type of
{}\texttt{Utility\-Base\-Factory\-::createUtility()} from a raw
{}\texttt{Utility\-Base*} pointer to a
{}\texttt{Ref\-Count\-Ptr<Utility\-Base>} object.  The new ``Abstract
Factory'' class declarations (assuming that the symbols from the
{}\texttt{Teuchos} namespace are in scope so that explicit
{}\texttt{Teuchos::} qualification is not necessary) become

{\small\begin{verbatim}
class UtilityBaseFactory {
public:
  virtual RefCountPtr<UtilityBase> createUtility() const = 0;
};

class UtilityAFactory : public UtilityBaseFactory {
public:
  RefCountPtr<UtilityBase> createUtility() const { return rcp(new UtilityA()); }
};

class UtilityBFactory : public UtilityBaseFactory {
public:
  RefCountPtr<UtilityBase> createUtility() const { return rcp(new UtilityB()); }
};
\end{verbatim}}

In addition to the change of the return type, the refactoring also
requires that calls to operator {}\texttt{new} be wrapped in calls to
the templated function {}\texttt{Teuchos\-::rcp(...)}.

The refactoring shown in Appendix {}\ref{rcpqs:apdx:ex-prg-refactored}
does not impact the definition of the class {}\texttt{ClientA} since
this class does not have any persisting relationships with any
other objects.  However, the definitions of the classes
{}\texttt{ClientB} and {}\texttt{ClientC} do change and become

{\small\begin{verbatim}
class ClientB {
  RefCountPtr<UtilityBase> utility_;
public:
  void initialize(const RefCountPtr<UtilityBase> &utility) { utility_=utility; }
  void g( const ClientA &a ) { a.f(*utility_); }
};

class ClientC {
  RefCountPtr<UtilityBaseFactory> utilityFactory_;
  RefCountPtr<UtilityBase>        utility_;
  bool                            shareUtility_;
public:
  ClientC( const RefCountPtr<UtilityBaseFactory> &utilityFactory, bool shareUtility )
    :utilityFactory_(utilityFactory)
    ,utility_(utilityFactory->createUtility())
    ,shareUtility_(shareUtility) {}
  void h( ClientB *b ) {
    if( shareUtility_ ) b->initialize(utility_);
    else                b->initialize(utilityFactory_->createUtility());
  }
};
\end{verbatim}}

The first thing that one should notice about the refactored
{}\texttt{ClientB} and {}\texttt{ClientC} classes is that their
destructors are gone.  It turns out that the compiler-generated
destructors do exactly the correct thing (i.e.~call the destructor on
the {}\texttt{Ref\-Count\-Ptr<>} data members which in turns calls
operator {}\texttt{delete} on the underlying reference-counted object
when the reference count goes to zero).  The second thing that one
should notice is that the old default constructor
{}\texttt{ClientB::ClientB()} which initialized the raw C++ pointer
{}\texttt{utility\_} to null is no longer needed since
{}\texttt{Ref\-Count\-Ptr<>} has a default constructor that does that.
A third thing to notice about these refactored client classes is that
the {}\texttt{Ref\-Count\-Ptr<>} objects are passed by
{}\texttt{const} reference (see Appendix
{}\ref{rcpqs:apdx:passing-args}) and not by value as the corresponding
raw pointers where in the original unfactored classes.  Passing
{}\texttt{Ref\-Count\-Ptr<>} objects by {}\texttt{const} reference
yields slightly more efficient code and simplifies stepping through
the code in a debugger.  For example, a function declared as

{\small\begin{verbatim}
void someFunction( RefCountPtr<A> a );
\end{verbatim}}

{}\noindent{}will always result in the copy constructor for
{}\texttt{Ref\-Count\-Ptr<>} being called (and therefore stepped into
in a debugger) while this same function declared as:

{\small\begin{verbatim}
void someFunction( const RefCountPtr<A> &a );
\end{verbatim}}

{}\noindent{}will often not require the copy constructor be called
(except in cases where an implicit conversion is being performed as
described in Appendix {}\ref{rcpqs:apdx:quickstart}) and thereby
easing debugging.

As an aside, note that Appendix {}\ref{rcpqs:apdx:passing-args} gives
recommended idioms for how to pass raw C++ objects and
{}\texttt{Ref\-Count\-Ptr<>}-wrapped objects to and from functions in
a way that result in function prototypes becoming as self documenting
as possible, help to avoid coding errors and increase the readability
of C++ code.  Also, in addition to the benefit that
{}\texttt{Ref\-Count\-Ptr<>} eases dynamic memory management, the
selective use of {}\texttt{Ref\-Count\-Ptr<>} and raw C++ object
references extends the vocabulary of the C++ language by helping to
distinguish between persisting and non-persisting associations.  For
example, when a one sees a function prototype where an object is
passed through a {}\texttt{Ref\-Count\-Ptr<>} such as

{\small\begin{verbatim}
class SomeClass {
public:
  void someFunction( const RefCountPtr<A> &a );
}
\end{verbatim}}

{}\noindent{}one can automatically deduce that ``memory'' of the
{}\texttt{A} object will be retained (through a private
{}\texttt{Ref\-Count\-Ptr<A>} data member in {}\texttt{Some\-Class} no
doubt) and that should automatically alter how the developer plans on
calling that function and passing the {}\texttt{A} object.  The
refactored C++ program in Appendix
{}\ref{rcpqs:apdx:ex-prg-refactored} provides an example of how the
idioms presented in Appendix {}\ref{rcpqs:apdx:passing-args} are put
to use.

%
\section{Additional and advanced features of {}\texttt{Ref\-Count\-Ptr<>}}
%

The use cases for {}\texttt{Ref\-Count\-Ptr<>} described above
comprise a large majority of the relavent use cases in most programs,
but there there are some other use cases that require additional and
more advanced features.  Some of these additional features (the C++
declarations for which are shown in Appendix
{}\ref{rcpqs:apdx:c++decl}) are mentioned below:

\begin{enumerate}

\item \textbf{Casting}

{}\texttt{Ref\-Count\-Ptr<>} objects can be casted in a manner similar
to casting raw C++ pointers and the same types of conversion rules
apply.  Analogs of the built-in casts {}\texttt{static\_\-cast<>},
{}\texttt{const\_\-cast<>} and {}\texttt{dynamic\_\-cast<>} are
supported by the non-member templated functions
{}\texttt{rcp\_\-static\_\-cast<>}, {}\texttt{rcp\_\-const\_\-cast<>}
and {}\texttt{rcp\_\-dynamic\_\-cast<>} respectively.  See Appendix
{}\ref{rcpqs:apdx:quickstart} for examples of how they are used.

\item \textbf{Reference-count information}

The function {}\texttt{Ref\-Count\-Ptr<>\-::count()} returns the
number of {}\texttt{Ref\-Count\-Ptr<>} objects that point to the
underlying reference-counted object.  This information can be useful
in some cases.

\item \textbf{Associating extra data with a reference-counted object}

There are some more difficult use cases where certain types of
information or other objects must be bundled with a reference-counted
object and must not be deleted until the reference-counted object is
deleted.  The non-member templated functions
{}\texttt{set\-\_extra\-\_data<>(...)} and
{}\texttt{get\-\_extra\-\_data<>(...)} serve this purpose (see item
({}\ref{rcpqs:apdx:qs:extra-data}) in Appendix
{}\ref{rcpqs:apdx:quickstart}).

\item \textbf{Customized deallocation policies}

The default behavior of {}\texttt{Ref\-Count\-Ptr<>} is to call
operator {}\texttt{delete} on reference-counted objects once the
reference count goes to zero.  While this is the most commonly needed
behavior, there are use cases where more specialized dellocation
polices are required.  For these cases, there is an overloaded form of
the templated function {}\texttt{Teuchos\-::rcp(...)} that takes a
templated deallocation policy object that defines how a
reference-counted object is deallocated when required.

\end{enumerate}

These features are discussed in detail in the design document
{}\cite{ref:RefCountPtr}.

%
\section{Summary}
%

The templated C++ class {}\texttt{Ref\-Count\-Ptr<>} provides a
low-overhead option for (almost) automatic memory management in C++.
This class has been developed and refined over many years and has been
instrumental in improving the quality of software projects that use it
consistently (for example see MOOCHO {}\cite{ref:moochouserguide}).
Careful use of {}\texttt{Ref\-Count\-Ptr<>} eliminates the need to
manually call operator {}\texttt{delete} when dynamically allocated
objects are no longer needed.  Furthermore, it helps to reduce the
amount of code that developers have to write.  For example, most
classes that use {}\texttt{Ref\-Count\-Ptr<>} for dynamically
allocated memory do not need developer-supplied destructors.  This
because the compiler-generated destructors do the exactly correct
thing which is to call destructors on an object's constituent data
members.  This was demonstrated in the difference between the original
and refactored classes {}\texttt{ClientB} and {}\texttt{ClientC}
described in Sections {}\ref{rcpbg:sec:original-program} and
{}\ref{rcpbg:sec:refactored-program}.

The class {}\texttt{Ref\-Count\-Ptr<>} also has advanced features not
found in other smart-pointer implementations such as the ability to
attach extra data and the customization of the deallocation policy.

% ---------------------------------------------------------------------- %
% References
%
\clearpage
\bibliographystyle{plain}
\bibliography{references}
\addcontentsline{toc}{section}{References}

% ---------------------------------------------------------------------- %
% Appendices should be stand-alone for SAND reports. If there is only
% one appendix, put \setcounter{secnumdepth}{0} after \appendix
%

\appendix

%
\section{C++ declarations for {}\texttt{Ref\-Count\-Ptr<>}}
\label{rcpqs:apdx:c++decl}
%

{\scriptsize\begin{verbatim}
namespace Teuchos {

enum ENull { null };

enum EPrePostDestruction { PRE_DESTROY, POST_DESTROY };

template<class T>
class DeallocDelete { public: void free( T* ptr ) { if(ptr) delete ptr; }  };

template<class T>
class DeallocArrayDelete { public: void free( T* ptr ) { if(ptr) delete [] ptr; }  };

template<class T>
class RefCountPtr {
public:
  typedef T  element_type;
  RefCountPtr( ENull null_arg = null );
  RefCountPtr(const RefCountPtr<T>& r_ptr);
  template<class T2> RefCountPtr(const RefCountPtr<T2>& r_ptr);
  ~RefCountPtr();
  RefCountPtr<T>& operator=(const RefCountPtr<T>& r_ptr);
  T* operator->() const;
  T& operator*() const;
  T* get() const;
  T* release();
  int count() const;
  void set_has_ownership();
  bool has_ownership() const;
  bool shares_resource(const RefCountPtr<T>& r_ptr) const;
private:
  ...
};

template<class T>            RefCountPtr<T>   rcp( T* p );
template<class T>            RefCountPtr<T>   rcp( T* p, bool owns_mem);
template<class T
  ,class Dealloc_T>          RefCountPtr<T>   rcp( T* p, Dealloc_T dealloc, bool owns_mem );
template<class T2, class T1> RefCountPtr<T2>  rcp_implicit_cast(const RefCountPtr<T1>& p1);
template<class T2, class T1> RefCountPtr<T2>  rcp_static_cast(const RefCountPtr<T1>& p1);
template<class T2, class T1> RefCountPtr<T2>  rcp_const_cast(const RefCountPtr<T1>& p1);
template<class T2, class T1> RefCountPtr<T2>  rcp_dynamic_cast(const RefCountPtr<T1>& p1
                                                ,bool throw_on_fail = false );
template<class T1, class T2> int              set_extra_data( const T1 &extra_data
                                                ,const std::string& name, RefCountPtr<T2> *p
                                                ,bool force_unique = true
                                                ,EPrePostDestruction destroy_when = POST_DESTROY );
template<class T1, class T2> T1&              get_extra_data( RefCountPtr<T2>& p
                                                ,const std::string& name );
template<class T1, class T2> const T1&        get_extra_data( const RefCountPtr<T2>& p
                                                ,const std::string& name );
template<class Dealloc_T
  , class T>                 Dealloc_T&       get_dealloc( RefCountPtr<T>& p );
template<class Dealloc_T
  , class T>                 const Dealloc_T& get_dealloc( const RefCountPtr<T>& p );

}
\end{verbatim}}

%
\section{\texttt{RefCountPtr<>} quick-start and reference}
\label{rcpqs:apdx:quickstart}
%

This appendix presents a short, but fairly comprehensive, quick-start
for the use of {}\texttt{Ref\-Count\-Ptr<>}.  The use cases described
here should cover the overwhelming majority of the use instances of
{}\texttt{Ref\-Count\-Ptr<>} in a typical program.

The following class hierarchy will be used in the C++ examples given
below.

{\small\begin{verbatim}
class A { public: virtual ~A(){} A& operator=(const A&){} virtual void f(){} };
class B1 : virtual public A {};
class B2 : virtual public A {};
class C : virtual public B1, virtual public B2 {};

class D {};
class E : public D {};
\end{verbatim}}

All of the following code examples used in this appendix are assumed
to be in the namespace {}\texttt{Teuchos} or have appropriate
{}\texttt{using Teuchos::...} declarations.  This removes the need to
explicitly use {}\texttt{Teuchos::} to qualify classes, functions and
other declarations from the {}\texttt{Teuchos} namespace.  Note that
some of the runtime checks are denoted as ``debug runtime checked''
which means that checking will only be performed in a debug build
(that is one where the macro {}\texttt{\_DEBUG} is defined at compile time).

\begin{enumerate}

\item {\bf Creation of \texttt{RefCountPtr<>} objects}

\begin{enumerate}

\item {\bf Creating a \texttt{RefCountPtr<>} object using \texttt{new}}
\label{rcpqs:apdx:qs:new}
%
 {\small\begin{verbatim}
RefCountPtr<C> c_ptr = rcp(new C);
\end{verbatim}}
%
\item {\bf Creating a \texttt{RefCountPtr<>} object to an array allocated using \texttt{new[n]}}
\label{rcpqs:apdx:qs:array-new}
%
 {\small\begin{verbatim}
RefCountPtr<C> c_ptr = rcp(new C[n],DeallocArrayDelete<C>(),true);
\end{verbatim}}
%
\item {\bf Initializing a \texttt{RefCountPtr<>} object to NULL}
\label{rcpqs:apdx:qs:null}
%
{\small\begin{verbatim}
RefCountPtr<C> c_ptr;
\end{verbatim}}
or
{\small\begin{verbatim}
RefCountPtr<C> c_ptr = null;
\end{verbatim}}
%
\item {\bf Initializing a \texttt{RefCountPtr<>} object to an object
       \underline{not} allocated with \texttt{new}}
\label{rcpqs:apdx:qs:not-new}
%
{\small\begin{verbatim}
C              c;
RefCountPtr<C> c_ptr = rcp(&c,false);
\end{verbatim}}
%
%
\item {\bf Representing constantness and non-constantness}
%
\begin{enumerate}
%
\item {\bf Non-constant pointer to non-constant object }
{\small\begin{verbatim}
RefCountPtr<C> c_ptr;
\end{verbatim}}
%
\item {\bf Constant pointer to non-constant object }
{\small\begin{verbatim}
const RefCountPtr<C> c_ptr;
\end{verbatim}}
%
\item {\bf Non-Constant pointer to constant object }
{\small\begin{verbatim}
RefCountPtr<const C> c_ptr;
\end{verbatim}}
%
\item {\bf Constant pointer to constant object }
{\small\begin{verbatim}
const RefCountPtr<const C> c_ptr;
\end{verbatim}}
%
\end{enumerate}
%
\item {\bf Copy constructor (implicit casting)}
%
{\small\begin{verbatim}
RefCountPtr<C>       c_ptr  = rcp(new C); // No cast
RefCountPtr<A>       a_ptr  = c_ptr;      // Cast to base class
RefCountPtr<const A> ca_ptr = a_ptr;      // Cast from non-const to const
\end{verbatim}}
%
\end{enumerate}

\item {\bf Reinitialization of \texttt{RefCountPtr<>} objects (using assignment operator)}
%
\begin{enumerate}
%
\item {\bf Resetting from a raw pointer}
%
{\small\begin{verbatim}
RefCountPtr<A> a_ptr;
a_ptr = rcp(new C());
\end{verbatim}}
%
\item {\bf Resetting to null}
%
{\small\begin{verbatim}
RefCountPtr<A> a_ptr = rcp(new C());
a_ptr = null; // The C object will be deleted here
\end{verbatim}}
%
\item {\bf Assigning from a \texttt{RefCountPtr<>} object}
%
{\small\begin{verbatim}
RefCountPtr<A> a_ptr1;
RefCountPtr<A> a_ptr2 = rcp(new C());
a_ptr1 = a_ptr2; // Now a_ptr1 and a_ptr2 point to same C object
\end{verbatim}}
%
\end{enumerate}

\item {\bf Accessing the reference-counted object}
%
\begin{enumerate}
%
\item {\bf Access to object reference (debug runtime checked)}
%
{\small\begin{verbatim}
C &c_ref = *c_ptr;
\end{verbatim}}
%
\item {\bf Access to object pointer (unchecked, may return \texttt{NULL})}
%
{\small\begin{verbatim}
C *c_rptr = c_ptr.get();
\end{verbatim}}
%
\item {\bf Access to object pointer (debug runtime checked, will not return \texttt{NULL})}
%
{\small\begin{verbatim}
C *c_rptr = &*c_ptr;
\end{verbatim}}
%
\item {\bf Access of object's member (debug runtime checked)}
%
{\small\begin{verbatim}
c_ptr->f();
\end{verbatim}}
%
<li> {\bf Testing for null}
%
{\small\begin{verbatim}
if( !a_ptr.get() ) std::cout << "a_ptr is null!\n";
\end{verbatim}}
%
or
%
{\small\begin{verbatim}
if( a_ptr == null ) std::cout << "a_ptr is null!\n";
\end{verbatim}}
%
or
%
{\small\begin{verbatim}
if( is_null(a_ptr) ) std::cout << "a_ptr is null!\n";
\end{verbatim}}

%
\end{enumerate}

\item {\bf Casting}
\label{rcpqs:apdx:qs:casting}
%
\begin{enumerate}
%
\item {\bf Implicit casting (see copy constructor above)}
%
\item {\bf Casting away \texttt{const}}
%
{\small\begin{verbatim}
RefCountPtr<const A>  ca_ptr = rcp(new C);
RefCountPtr<A>        a_ptr  = rcp_const_cast<A>(ca_ptr); // cast away const!
\end{verbatim}}
%
\item {\bf Static cast (no runtime check)}
%
{\small\begin{verbatim}
RefCountPtr<D>  d_ptr = rcp(new E);
RefCountPtr<E>  e_ptr = rcp_static_cast<E>(d_ptr); // Unchecked, unsafe?
\end{verbatim}}
%
\item {\bf Dynamic cast (runtime checked, failed cast allowed)}
%
{\small\begin{verbatim}
RefCountPtr<A>  a_ptr  = rcp(new C);
RefCountPtr<B1> b1_ptr = rcp_dynamic_cast<B1>(a_ptr);  // Checked, safe!
RefCountPtr<B2> b2_ptr = rcp_dynamic_cast<B2>(b1_ptr); // Checked, safe!
RefCountPtr<C>  c_ptr  = rcp_dynamic_cast<C>(b2_ptr);  // Checked, safe!
\end{verbatim}}
%
\item {\bf Dynamic cast (runtime checked, failed cast not allowed)}
%
{\small\begin{verbatim}
RefCountPtr<A>  a_ptr1  = rcp(new C);
RefCountPtr<A>  a_ptr2  = rcp(new A);
RefCountPtr<B1> b1_ptr1 = rcp_dynamic_cast<B1>(a_ptr1,true); // Success!
RefCountPtr<B1> b1_ptr2 = rcp_dynamic_cast<B1>(a_ptr2,true); // Throw std::bad_cast!
\end{verbatim}}
%
\end{enumerate}

\item {\bf Managing extra data}
\label{rcpqs:apdx:qs:extra-data}
%
\begin{enumerate}
%
\item {\bf Adding extra data (post destruction of extra data)}
%
{\small\begin{verbatim}
set_extra_data(rcp(new B1),"A:B1",&a_ptr);
\end{verbatim}}
%
\item {\bf Adding extra data (pre destruction of extra data)}
%
{\small\begin{verbatim}
set_extra_data(rcp(new B1),"A:B1",&a_ptr,PRE_DESTORY);
\end{verbatim}}
%
\item {\bf Retrieving extra data}
%
{\small\begin{verbatim}
get_extra_data<RefCountPtr<B1> >(a_ptr,"A:B1")->f();
\end{verbatim}}
%
\item {\bf Resetting extra data}
%
{\small\begin{verbatim}
get_extra_data<RefCountPtr<B1> >(a_ptr,"A:B1") = rcp(new C);
\end{verbatim}}
%
\end{enumerate}

\end{enumerate}

%
\section{Commandments for the use of {}\texttt{Ref\-Count\-Ptr<>}}
\label{rcpqs:apdx:commandments}
%

Here are listed commandments for the use of
{}\texttt{Ref\-Count\-Ptr<>}.  These commandments reinforce some of
the material in the quick-start in Appendix
{}\ref{rcpqs:apdx:quickstart}.  The reasoning behind these
commandments can be found in the design document for
{}\texttt{Ref\-Count\-Ptr<>} {}\cite{ref:RefCountPtr}.  Along with
each commandment is one or more anti-commandments stating the negative
of the commandment.  C++ code fragments are also included to
demonstrate each commandment and anti-commandment.

\begin{commandment}\label{rcp:cmd:rcp-new}
Thou shall put a pointer for an object allocated with operator
{}\texttt{new} into a {}\texttt{Ref\-Count\-Ptr<>} object only once.
The best way to insure this is to call operator {}\texttt{new}
directly in a call to {}\texttt{rcp(...)} to create a dynamically
allocated object that is to be managed by a
{}\texttt{Ref\-Count\-Ptr<>} object.  See item
({}\ref{rcpqs:apdx:qs:new}) in Appendix
{}\ref{rcpqs:apdx:quickstart}.
\end{commandment}

\begin{anticommandment}
Thou shall never give a raw C++ pointer returned from operator
{}\texttt{new} to more than one {}\texttt{Ref\-Count\-Ptr<>} object.
\end{anticommandment}

{}\noindent{}Example:
{\small\begin{verbatim}
  A *ra_ptr = new C;
  RefCountPtr<A> a_ptr1 = rcp(ra_ptr); // Okay
  RefCountPtr<A> a_ptr2 = rcp(ra_ptr); // no, No, NO !!!!
\end{verbatim}}

\begin{commandment}\label{rcp:cmd:rcp-new}
Thou shall only create a {}\texttt{Ref\-Count\-Ptr<>} object using a
raw C++ pointer created from {}\texttt{new[]} using {}\texttt{rcp(new
C[n],DeallocArrayDelete<C)(),true)}.  See item
({}\ref{rcpqs:apdx:qs:array-new}) in Appendix
{}\ref{rcpqs:apdx:quickstart}.
\end{commandment}

\begin{anticommandment}
Thou shall never give a raw C++ pointer to an array of objects
returned from operator {}\texttt{new[]} to a
{}\texttt{Ref\-Count\-Ptr<>} object using {}\texttt{rcp(new C[n])}.
\end{anticommandment}

{}\noindent{}Example:
{\small\begin{verbatim}
  RefCountPtr<std::vector<C> > c_array_ptr1 = rcp(new std::vector<C>(N)); // Okay
  RefCountPtr<C>               c_array_ptr2 = rcp(new C[n]
                                               ,DeallocArrayDelete<C>()
                                               ,true);                    // Okay
  RefCountPtr<C>               c_array_ptr3 = rcp(new C[n]);              // no, No, NO!
\end{verbatim}}

\begin{commandment}
Thou shall only create a {}\texttt{NULL} {}\texttt{Ref\-Count\-Ptr<>}
object by using the default constructor or by using the
{}\texttt{null} enum (and its associated special constructor) (see
item ({}\ref{rcpqs:apdx:qs:null}) in Appendix
{}\ref{rcpqs:apdx:quickstart}).  Trying to assign to {}\texttt{NULL}
or {}\texttt{0} will not compile.
\end{commandment}

\begin{anticommandment}
Thou shall not create a {}\texttt{NULL} {}\texttt{Ref\-Count\-Ptr<>}
object using the templated function {}\texttt{rcp(...)} since it is
very verbose and complicates maintenance.
\end{anticommandment}

{}\noindent{}Example:
{\small\begin{verbatim}
  RefCountPtr<A> a_ptr1 = null;          // Yes :-)
  RefCountPtr<A> a_ptr2 = rcp<A>(NULL);  // No, too verbose :-(
\end{verbatim}}

\begin{commandment}
Thou shall only pass a raw pointer for an object that is
{}\underline{not} allocated by operator {}\texttt{new} (e.g.~allocated
on the stack) into a {}\texttt{Ref\-Count\-Ptr<>} object by using the
templated function {}\texttt{rcp<T>(T* p, bool owns\_mem)} and setting
{}\texttt{owns\_mem} to {}\texttt{false} (see item
({}\ref{rcpqs:apdx:qs:not-new}) in Appendix
{}\ref{rcpqs:apdx:quickstart}).
\end{commandment}

\begin{anticommandment}
Thou shall never pass a pointer for an object {}\underline{not}
allocated with operator {}\texttt{new} into a
{}\texttt{Ref\-Count\-Ptr<>} object without setting
{}\texttt{owns\_mem} to {}\texttt{false}.
\end{anticommandment}

{}\noindent{}Example:
{\small\begin{verbatim}
  C c;
  RefCountPtr<A> a_ptr1 = rcp(&c,false);  // Yes :-)
  RefCountPtr<A> a_ptr2 = rcp(&c);        // no, No, NO !!!!
\end{verbatim}}

\begin{commandment}\label{rcp:cmnd:converstion}
Thou shalt only cast between {}\texttt{Ref\-Count\-Ptr<>} objects
using the default copy constructor (for implicit conversions) and the
nonmember template functions
{}\texttt{rcp\-\_static\-\_cast<>(\-...)},
{}\texttt{rcp\-\_const\-\_cast<>(\-...)} and
{}\texttt{rcp\-\_dynamic\-\_cast<>(\-...)}  (see item
({}\ref{rcpqs:apdx:qs:casting}) in Appendix
{}\ref{rcpqs:apdx:quickstart}).
\end{commandment}

\begin{anticommandment}
Thou shall never convert between {}\texttt{Ref\-Count\-Ptr<>} objects
using raw pointer access.
\end{anticommandment}

{}\noindent{}Example:
{\small\begin{verbatim}
  RefCountPtr<A>     a_ptr   = rcp(new C);
  RefCountPtr<B1>    b1_ptr1 = rcp_dynamic_cast<B1>(a_ptr);         // Yes :-)
  RefCountPtr<B1>    b1_ptr2 = rcp(dynamic_cast<B1*>(a_ptr.get())); // no, No, NO !!!
\end{verbatim}}

%
\section{Recommendations for passing objects to and from C++ functions}
\label{rcpqs:apdx:passing-args}
%

Below are recommended idioms for passing required\footnote{Required
arguments must be bound to valid objects (i.e.~can not be
{}\texttt{NULL})} and optional\footnote{Optional arguments may be
{}\texttt{NULL} in some cases} arguments into and out of C++ functions
for various use cases and different types of objects.  These idioms
show how to write function arguments prototypes which exploit the C++
language in a way that makes these function prototypes as self
documenting as possible, avoid coding errors and increase readability
of C++ code.  In general, {}\texttt{Ref\-Count\-Ptr<T>} objects should
be passed and manipulated as though they where raw C++ pointer
{}\texttt{T*} objects.  However, while raw C++ pointer objects should
generally be passed by value, {}\texttt{Ref\-Count\-Ptr<>} objects
should generally be passed by reference for several reasons (see
{}\cite{ref:RefCountPtr} for more details).

%
%\fbox{
\begin{center}
\begin{minipage}{{}\textwidth}
\begin{tabular}{|c|c|c|}
\hline
Argument purpose
& Non-Persisting
& Persisting \\
\hline
\hline
non-mutable object (required$^1$)
& \begin{minipage}{12ex}
    \begin{center}
    {\tiny .}\\
    {}\texttt{S s} \\
    or \\
    {}\texttt{const S s} \\
    or \\
    {}\texttt{const S \&s} \\
    {\tiny .}
    \end{center}
  \end{minipage}
& {}\texttt{const RefCountPtr<const S> \&s} \\
\hline
non-mutable object (optional$^2$)
& {}\texttt{const S *s}
& {}\texttt{const RefCountPtr<const S> \&s} \\
\hline
mutable object
& {}\texttt{S *s}
& {}\texttt{const RefCountPtr<S> \&s} \\
\hline
array of non-mutable objects
& {}\texttt{const S s[]}
& {}\texttt{const RefCountPtr<const S> s[]} \\
\hline
array of mutable objects
& {}\texttt{S s[]}
& {}\texttt{const RefCountPtr<S> s[]} \\
\hline
\end{tabular}
\begin{center}
C++ declarations for passing small concrete (i.e.~with value
semantics) objects to and from functions where {}\texttt{S} is a place
holder for an actual built-in or user-defined data type.
\end{center}
\end{minipage}
\end{center}
%} % end fbox
%
%\\[5ex]
%
%\fbox{
\begin{center}
\begin{minipage}{{}\textwidth}
\begin{tabular}{|c|c|c|}
\hline
Argument purpose
& Non-Persisting
& Persisting \\
\hline
\hline
non-mutable object (required$^1$)
& {}\texttt{const A \&a}
& {}\texttt{const RefCountPtr<const A> \&a} \\
\hline
non-mutable object (optional$^2$)
& {}\texttt{const A *a}
& {}\texttt{const RefCountPtr<const A> \&a} \\
\hline
mutable object
& {}\texttt{A *a}
& {}\texttt{const RefCountPtr<A> \&a} \\
\hline
array of non-mutable objects
& {}\texttt{const A* a[]}
& {}\texttt{const RefCountPtr<const A> a[]} \\
\hline
array of mutable objects
& {}\texttt{A* a[]}
& {}\texttt{const RefCountPtr<A> a[]} \\
\hline
\end{tabular}
\begin{center}
C++ declarations for passing abstract (i.e.~with reference or pointer
semantics) or large concrete objects to and from functions where
{}\texttt{A} is a place holder for an actual abstract C++ base class.
\end{center}
\end{minipage}
\end{center}
%} % end fbox

%
\section{Listing: Example C++ program using raw dynamic memory management}
\label{rcpqs:apdx:ex-prg}
%

{\small\begin{verbatim}
#include "example_get_args.hpp"

// Abstract interfaces
class UtilityBase {
public:
  virtual void f() const = 0;
};
class UtilityBaseFactory {
public:
  virtual UtilityBase* createUtility() const = 0;
};

// Concrete implementations
class UtilityA : public UtilityBase {
public:
  void f() const { std::cout<<"\nUtilityA::f() called, this="<<this<<"\n"; }
};
class UtilityB : public UtilityBase {
public:
  void f() const { std::cout<<"\nUtilityB::f() called, this="<<this<<"\n"; }
};
class UtilityAFactory : public UtilityBaseFactory {
public:
  UtilityBase* createUtility() const { return new UtilityA(); }
};
class UtilityBFactory : public UtilityBaseFactory {
public:
  UtilityBase* createUtility() const { return new UtilityB(); }
};

// Client classes
class ClientA {
public:
  void f( const UtilityBase &utility ) const { utility.f(); }
};
class ClientB {
  UtilityBase *utility_;
public:
  ClientB() : utility_(0) {}
  ~ClientB() { delete utility_; }
  void initialize( UtilityBase *utility ) { utility_ = utility; }
  void g( const ClientA &a ) { a.f(*utility_); }
};
class ClientC {
  const UtilityBaseFactory *utilityFactory_;
  UtilityBase              *utility_;
  bool                     shareUtility_;
public:
  ClientC( const UtilityBaseFactory *utilityFactory, bool shareUtility )
    :utilityFactory_(utilityFactory)
    ,utility_(utilityFactory->createUtility())
    ,shareUtility_(shareUtility) {}
  ~ClientC() { delete utilityFactory_; delete utility_; }
  void h( ClientB *b ) {
    if( shareUtility_ ) b->initialize(utility_);
    else                b->initialize(utilityFactory_->createUtility());
  }
};

// Main program
int main( int argc, char* argv[] )
{
  // Read options from the commandline
  bool useA, shareUtility;
  example_get_args(argc,argv,&useA,&shareUtility);
  // Create factory
  UtilityBaseFactory *utilityFactory = 0;
  if(useA) utilityFactory = new UtilityAFactory();
  else     utilityFactory = new UtilityBFactory();
  // Create clients
  ClientA a;
  ClientB b1, b2;
  ClientC c(utilityFactory,shareUtility);
  // Do some stuff
  c.h(&b1);
  c.h(&b2);
  b1.g(a);
  b2.g(a);
  // Cleanup memory
  delete utilityFactory;
}
\end{verbatim}}

%
\section{Listing: Refactored example C++ program using {}\texttt{Ref\-Count\-Ptr<>}}
\label{rcpqs:apdx:ex-prg-refactored}
%

{\small\begin{verbatim}
#include "Teuchos_RefCountPtr.hpp"
#include "example_get_args.hpp"

// Inject symbols for RefCountPtr so we don't need Teuchos:: qualification
using Teuchos::RefCountPtr;
using Teuchos::rcp;

// Abstract interfaces
class UtilityBase {
public:
  virtual void f() const = 0;
};
class UtilityBaseFactory {
public:
  virtual RefCountPtr<UtilityBase> createUtility() const = 0;
};

// Concrete implementations
class UtilityA : public UtilityBase {
public:
  void f() const { std::cout<<"\nUtilityA::f() called, this="<<this<<"\n"; }
};
class UtilityB : public UtilityBase {
public:
  void f() const { std::cout<<"\nUtilityB::f() called, this="<<this<<"\n"; }
};
class UtilityAFactory : public UtilityBaseFactory {
public:
  RefCountPtr<UtilityBase> createUtility() const { return rcp(new UtilityA()); }
};
class UtilityBFactory : public UtilityBaseFactory {
public:
  RefCountPtr<UtilityBase> createUtility() const { return rcp(new UtilityB()); }
};

// Client classes
class ClientA {
public:
  void f( const UtilityBase &utility ) const { utility.f(); }
};
class ClientB {
  RefCountPtr<UtilityBase> utility_;
public:
  void initialize(const RefCountPtr<UtilityBase> &utility) { utility_=utility; }
  void g( const ClientA &a ) { a.f(*utility_); }
};
class ClientC {
  RefCountPtr<UtilityBaseFactory> utilityFactory_;
  RefCountPtr<UtilityBase>        utility_;
  bool                            shareUtility_;
public:
  ClientC( const RefCountPtr<UtilityBaseFactory> &utilityFactory, bool shareUtility )
    :utilityFactory_(utilityFactory)
    ,utility_(utilityFactory->createUtility())
    ,shareUtility_(shareUtility) {}
  void h( ClientB *b ) {
    if( shareUtility_ ) b->initialize(utility_);
    else                b->initialize(utilityFactory_->createUtility());
  }
};

// Main program
int main( int argc, char* argv[] )
{
  // Read options from the commandline
  bool useA, shareUtility;
  example_get_args(argc,argv,&useA,&shareUtility);
  // Create factory
  RefCountPtr<UtilityBaseFactory> utilityFactory;
  if(useA) utilityFactory = rcp(new UtilityAFactory());
  else     utilityFactory = rcp(new UtilityBFactory());
  // Create clients
  ClientA a;
  ClientB b1, b2;
  ClientC c(utilityFactory,shareUtility);
  // Do some stuff
  c.h(&b1);
  c.h(&b2);
  b1.g(a);
  b2.g(a);
}
\end{verbatim}}

%
% The Glossary
%

%\begin{theglossary}
%\entry{non-persisting relationship}
%A relationship that exits between two objects only during the
%execution of a function.
%\entry{persisting relationship}
%A relationship that exits between two objects that spans
%two or more function calls and may linger until the destruction
%of one or more of the related objects.
%\end{theglossary}

%
\begin{SANDdistribution}
%

% External
\SANDdistExternal{1}{} Carl Laird \\ Department Chemical Engineering\\Carnegie Mellon University\\5000 Forms Ave.\\Pittsburgh, PA 15213
\SANDdistExternal{1}{} Matthias Heinkenschloss \\ Department of Computational and Applied Mathematics\\MS 134 Rice University\\
6100 S. Main Street\\Houston, TX 77005-1892
\SANDdistExternal{1}{} Bill Symes\\Department of Computational and Applied Mathematics\\MS 134 Rice University\\
6100 S. Main Street\\Houston, TX 77005-1892
\SANDdistExternal{1}{} Tony Padula\\Department of Computational and Applied Mathematics\\MS 134 Rice University\\
6100 S. Main Street\\Houston, TX 77005-1892
\SANDdistExternal{1}{} Mark Gockenbach \\ Department of Mathematical Sciences\\Michigan Technological University\\ 
1400 Townsend Drive\\Houghton, Michigan 49931-1295, U.S.A.
\SANDdistExternal{1}{} Paul Sexton \\ Box 1560 \\ St. John's University \\ Collegeville, MN 56321
%\SANDdistExternal{1}{} Andreas Wachter \\  \\ IBM Watson Research Center \\
%???Address???
% Sandia Line
%\SANDdistInternal{1}{0847}{Bill Camp}{9200}
%\SANDdistInternal{1}{0847}{Sudip Dosanjh}{9233}
% 9211
\SANDdistInternal{1}{0370}{Scott Mitchell}{9211}
\SANDdistInternal{1}{0370}{David Gay}{9211}
\SANDdistInternal{5}{0370}{Roscoe Bartlett}{9211}
\SANDdistInternal{1}{0370}{Scott Collis}{9211}
\SANDdistInternal{1}{0370}{Bart van Bloemen Waanders}{9211}
\SANDdistInternal{1}{0370}{Mike Eldred}{9211}
\SANDdistInternal{1}{0370}{Laura Swiler}{9211}
% 9214
\SANDdistInternal{1}{9159}{Mark Adams}{9214}
\SANDdistInternal{1}{1110}{Pavel Bochev}{9214}
\SANDdistInternal{1}{1110}{Todd Coffey}{9214}
\SANDdistInternal{1}{1110}{David Day}{9214}
\SANDdistInternal{1}{1110}{John Delaurentis}{9214}
\SANDdistInternal{1}{1110}{Michael Heroux}{9214}
\SANDdistInternal{1}{1110}{Ulrich Hetmaniuk}{9214}
\SANDdistInternal{1}{9217}{Jonathan Hu}{9214}
\SANDdistInternal{1}{1110}{Richard Lehoucq}{9214}
\SANDdistInternal{1}{1110}{Louis Romero}{9214}
\SANDdistInternal{1}{1110}{David Ropp}{9214}
\SANDdistInternal{1}{1110}{Mazio Sala}{9214}
\SANDdistInternal{1}{1110}{Kendall Stanley}{9214}
\SANDdistInternal{1}{1110}{Heidi Thornquist}{9214}
\SANDdistInternal{1}{9217}{Raymond Tuminaro}{9214}
\SANDdistInternal{1}{1110}{James Willenbring}{9214}
% 9215
\SANDdistInternal{1}{1110}{William Hart}{9215}
\SANDdistInternal{1}{1110}{Erik Boman}{9215}
% 9233
% 9210
%\SANDdistInternal{1}{1110}{David Womble}{9210}
% 8962
%\SANDdistInternal{1}{9159}{Steve Thomas}{8962}
\SANDdistInternal{1}{9159}{Paul Boggs}{8962}
\SANDdistInternal{1}{9159}{Kevin Long}{8962}
\SANDdistInternal{1}{9159}{Patricia Hough}{8962}
\SANDdistInternal{1}{9159}{Tamara Kolda}{8962}
\SANDdistInternal{1}{9159}{Monica Martinez-Canales}{8962}
\SANDdistInternal{1}{9159}{Pamela Williams}{8962}
\SANDdistInternal{1}{9159}{Victoria Howle}{8962}
% Sandia Misc
%\SANDdistInternal{1}{0847}{Steve Wojtkiewicz}{9124}
% Xyce developers
\SANDdistInternal{1}{0316}{Eric Keiter}{9233}
\SANDdistInternal{1}{0316}{Scott Hutchinson}{9233}
\SANDdistInternal{1}{0316}{Robert Hoekstra}{9233}
% Premo developers
\SANDdistInternal{1}{0316}{Curt Ober}{9233}
\SANDdistInternal{1}{0316}{Tom Smith}{9233}
\SANDdistInternal{1}{0316}{Russel Hooper}{9233}
% Main Sierra developers
\SANDdistInternal{1}{0382}{Carter Edwards}{9143}
\SANDdistInternal{1}{0382}{James Stewart}{9143}
\SANDdistInternal{1}{0316}{Alan Williams}{9143}
% Main Nevada developers
\SANDdistInternal{1}{0617}{Ricard Drake}{9231}
% NOX/LOCA developers
\SANDdistInternal{1}{0316}{Roger Pawlowski}{9233}
\SANDdistInternal{1}{0316}{Eric Phipps}{9233}
\SANDdistInternal{1}{1110}{Andrew Salinger}{9233}
\SANDdistInternal{1}{1110}{Brett Bader}{9233}
% Charon developers
\SANDdistInternal{1}{0316}{Gary Hennigan}{9233}
% Other Trilinos developers
% Housekeeping copies necessary for every unclassified report:
\SANDdistInternal{1}{9018}{Central Technical Files}{8945-1}
\SANDdistInternal{2}{0899}{Technical Library}{9610}
\SANDdistInternal{2}{0612}{Review \& Approval Desk}{4916}
% If report has a Patent Caution or Patent Interest, add this:
%\SANDdistInternal{3}{0161}{Patent and Licensing Office}{4916}
\end{SANDdistribution}

\end{document}
