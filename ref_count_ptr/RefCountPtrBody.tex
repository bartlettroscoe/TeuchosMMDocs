%
\section{Introduction to {}\texttt{RefCountPtr<>}}
\label{rcp:sec:intro}
%

Described herein is the templated class {}\texttt{RefCountPtr<>}
(which exists in the namespace {}\texttt{Teuchos}) and a set of global
template functions for implementing automatic garbage collection in
C++ using smart reference-counted pointers.  This code is included in
the Trilinos {}\cite{ref:Trilinos-Overview} tools package
{}\texttt{Teuchos}.  This design is based partly on the interface for
{}\texttt{std::auto\_ptr<>} and Items 28 and 29 in "More Effective
C++" by Scott Myers {}\cite{ref:meyers_1996}.  In short, using this
class allows one client to dynamically create an object (using
{}\texttt{new} for instance), pass the object around to many other
clients which also need to access the object and then never requiring
any client to explicitly call delete.  The object will (almost
magically) be deleted when all of the clients remove their references
to it.  This is very similiar to the type of garbage collection that
is in languages like Perl and Java.  There are, however, some
pathological cases (such as the classic problem of circular
references, see {}\cite[Item 29, page 212]{ref:meyers_1996}) where
{}\texttt{RefCountPtr<>} will result in a memory leak but these
situations can be avoided.  However, realizing the potential of
hands-off garbage collection with {}\texttt{RefCountPtr<>} requires
following some rules.  These rules are spelled out in the form of
commandments in the following discussion.

This discussion assumes that the reader is knowledgeable of C++ and
has read books such as {}\cite{ref:stroustrup_2000} and
{}\cite{ref:meyers_1994}.  While understanding and appreciating the
advanced features of {}\texttt{RefCountPtr<>} requires advanced C++
knowledge and experience, the basic use requires only basic C++
skills.  By ``coding by example'' even beginner C++ programmers can to
realize the benefits of {}\texttt{RefCountPtr<>}.

The following class hierarchy is used to demonstrate this smart
pointer design.
%
{\scriptsize\begin{verbatim}
class A { public: virtual ~A(){} A& operator=(const A&){} virtual void f(){} };
class B1 : virtual public A {};
class B2 : virtual public A {};
class C : virtual public B1, virtual public B2 {};
class D {};
class E : public D {};
\end{verbatim}}
%
Note that the classes {}\texttt{A}, {}\texttt{B1}, {}\texttt{B2} and
{}\texttt{C} are polymorphic (with multiple inheritance using virtual
base classes) while the classes {}\texttt{D} and {}\texttt{E} are not.
In the following description, all of the code examples are written as
though there was a {}\texttt{using namespace Teuchos;} declaration is
the current scope or all of the code resides in the {}\texttt{Teuchos}
namespace.

The public C++ declarations for all of the code discussed here are
shown in Figure {}\ref{rcp:fig:decl}.  A short quick-start and
reference for {}\texttt{RefCountPtr<>} is contained in Appendix
{}\ref{rcp:apdx:quickstart}.

\begin{figure}
{\scriptsize\begin{verbatim}
namespace Teuchos {

enum ENull { null };

template<class T>
class DeallocDelete { public: void free( T* ptr ) { if(ptr) delete ptr; }  };

template<class T>
class RefCountPtr {
public:
  typedef T  element_type;
  RefCountPtr( ENull null_arg = null );
  RefCountPtr(const RefCountPtr<T>& r_ptr);
  template<class T2> RefCountPtr(const RefCountPtr<T2>& r_ptr);
  ~RefCountPtr();
  RefCountPtr<T>& operator=(const RefCountPtr<T>& r_ptr);
  T* operator->() const;
  T& operator*() const;
  T* get() const;
  T* release();
  int count() const;
  void set_has_ownership();
  bool has_ownership() const;
  bool shares_resource(const RefCountPtr<T>& r_ptr) const;
private:
  ...
};

template<class T>            RefCountPtr<T>   rcp( T* p );
template<class T>            RefCountPtr<T>   rcp( T* p, bool owns_mem);
template<class T
  ,class Dealloc_T>          RefCountPtr<T>   rcp( T* p, Dealloc_T dealloc, bool owns_mem );
template<class T2, class T1> RefCountPtr<T2>  rcp_implicit_cast(const RefCountPtr<T1>& p1);
template<class T2, class T1> RefCountPtr<T2>  rcp_static_cast(const RefCountPtr<T1>& p1);
template<class T2, class T1> RefCountPtr<T2>  rcp_const_cast(const RefCountPtr<T1>& p1);
template<class T2, class T1> RefCountPtr<T2>  rcp_dynamic_cast(const RefCountPtr<T1>& p1);
template<class T1, class T2> int              set_extra_data( const T1 &extra_data
                                                , RefCountPtr<T2> *p, int ctx = -1 );
template<class T1, class T2> T1&              get_extra_data( RefCountPtr<T2>& p, int ctx );
template<class T1, class T2> const T1&        get_extra_data( const RefCountPtr<T2>& p, int ctx );
template<class Dealloc_T
  , class T>                 Dealloc_T&       get_dealloc( RefCountPtr<T>& p );
template<class Dealloc_T
  , class T>                 const Dealloc_T& get_dealloc( const RefCountPtr<T>& p );

}
\end{verbatim}}
\caption{\label{rcp:fig:decl}
Declaration of C++ code for {}\texttt{RefCountPtr<>} and supporting functions.}
\end{figure}

A word of caution, note that the design of the reference-counted smart
pointer class discussed in Item 29 of {}\cite{ref:meyers_1996} in the
subsection ``Adding Reference Counting to Existing Classes'' has a
purpose very similary to {}\texttt{RefCountPtr<>} but the design of
{}\texttt{RefCountPtr<>} is very different (ToDo: Discuss the C++
design of {}\texttt{RefCountPtr<>} in an appendix).  Therefore, while
the designs discussed in {}\cite{ref:meyers_1996} are not used in
their presented form, this reference does discuss in detail many of
the issues involved in using smart pointers and reference counting and
hense provides very useful background information and interested
readers are strongly encurraged to study this reference.

%
\subsection{Initializing {}\texttt{RefCountPtr} objects}
\label{rcp:sec:init-rcp-objects}
%

A smart reference-counted pointer to a dynammicallly allocated object
(of type {}\texttt{A} for instance) is initialized as follows
%
{\scriptsize\begin{verbatim}
RefCountPtr<A>             a_ptr   = rcp(new A); // A       *       a_ptr   = new A;
RefCountPtr<const A>       ca_ptr  = rcp(new A); // const A *       ca_ptr  = new A;
const RefCountPtr<A>       a_cptr  = rcp(new A); // A       * const a_cptr  = new A;
const RefCountPtr<const A> ca_cptr = rcp(new A); // const A * const ca_cptr = new A;
\end{verbatim}}
%
The above code shows how all the various combinations for
{}\texttt{const} or non-{}\texttt{const} pointers to {}\texttt{const}
or non-{}\texttt{const} objects are expressed (this is explained in
more detail in Item 28 in {}\cite{ref:meyers_1996}).  There is no
automatic conversion from raw pointers to smart pointers for many good
reasons (again, see Item 28 in {}\cite{ref:meyers_1996}).  To allow such
an implicit conversion almost guarentees memory
allocation/deallocation errors will occur.  Therefore, the following
templated function
%
{\scriptsize\begin{verbatim}
template<class T> RefCountPtr<T> rcp(T* p);
\end{verbatim}}
%
\noindent{}
must be used to initialize a smart pointer object given a raw pointer.
The reason for this is somewhat complicated but it is related to
multiple inheritance and/or virtual base classes (see Appendix
{}\ref{rcp:apdx:mivbc}).

\begin{commandment}\label{rcp:cmd:rcp-new}
Thou shall only call {}\texttt{new} directly
in the call to {}\texttt{rcp(...)} to create a dynamically allocated
object that is to be managed by a {}\texttt{RefCountPtr<>} object.
\end{commandment}

The only case where the template function {}\texttt{rcp<>(...)} should
not be used to create a smart pointer is the initialization to
{}\texttt{NULL}.  One way to initialize a null smart pointer is to just
use the default constructor as
%
{\scriptsize\begin{verbatim}
RefCountPtr<A> a_ptr;   // A a_ptr = NULL:
\end{verbatim}}
%
One of the big pluses for using {}\texttt{RefCountPtr<>} over raw
pointers (independent of the reference counting and garbage collection
features) is this default initialization to {}\texttt{NULL}.
To be more explicit about the initialization to {}\texttt{NULL} (and for
passing a null pointer into a function), a special constructor is
included which takes the enumeration value {}\texttt{null}.  For example
%
{\scriptsize\begin{verbatim}
RefCountPtr<A> a_ptr = null; // i.e. A a_ptr = NULL:
\end{verbatim}}
%

\begin{commandment}
Thou shall only create a {}\texttt{NULL}
{}\texttt{RefCountPtr<>} object by using the default constructor
or by using the {}\texttt{null} enum (and its associated special
constructor).
\end{commandment}

Another situation that commonly occurs is when an object is allocated
on the stack, but must be passed to a client that only accepts a
{}\texttt{RefCountPtr<>} object.  For example, suppose that there is a
class {}\texttt{Foo} that is declared as follows
%
{\scriptsize\begin{verbatim}
class Foo {
public:
    Foo(
    void f() { a_->f() };
private:
    RefCountPtr<A>  a_;
};
\end{verbatim}}
%
The following code fragment shows how to allocate an object of concrete
type {}\texttt{C} on the stack and then pass this object into the constructor
for {}\texttt{Foo}
%
{\scriptsize\begin{verbatim}
C c;
Foo foo(rcp(&c,false));
\end{verbatim}}
%
In this example, the templated function
%
{\scriptsize\begin{verbatim}
template<class T> RefCountPtr<T> rcp( T* p, bool owns_mem );
\end{verbatim}}
%
\noindent{}
is used with the parameter {}\texttt{owns\_mem} set to
{}\texttt{false}.  In this example, when the {}\texttt{foo} object
goes out of scope (and its {}\texttt{Foo::a\_} member is deleted),
{}\texttt{delete} will not be called on the underlying pointer and no
memory error will occur.  For more specialized types of memory
deallocation control see Section {}\ref{rcp:sec:dealloc}.

\begin{commandment}
Thou shall only pass a raw pointer for an object that is
\underline{not} allocated by {}\texttt{new} (e.g.~allocated on the stack) into a
{}\texttt{RefCountPtr<>} object by using the templated function
{}\texttt{rcp<T>(T* p, bool owns\_mem)} and setting {}\texttt{owns\_mem} to
{}\texttt{false}.
\end{commandment}

%
\subsection{Accessing the underlying reference-counted object}
%

Through the magic of the overloaded member operator functions
{}\texttt{RefCountPtr<T>::operator->()} and
{}\texttt{RefCountPtr<T>::operator*()}, the underlying object being reference
counted can be accessed exactly the same as for raw pointers such as
follows

{\scriptsize\begin{verbatim}
a_ptr->f();
(*a_ptr).f();
\end{verbatim}}

Therefore, using a smart reference-counted pointer is very similar to
using a raw C++ pointer.  Some things you can do with smart
reference-counted pointers that are similar as for raw pointers are

{\scriptsize\begin{verbatim}
RefCountPtr<A>
  a_ptr1     = rcp(new A),   // Initialize them from a raw pointer from new
  a_ptr2     = rcp(new A);   // ""
A *ra_ptr1   = new A,        // ""
  *ra_ptr2   = new A;        // ""
a_ptr1       = rcp(ra_ptr2); // Assign from a raw pointer (only do this once!)
a_ptr2       = a_ptr1;       // Assign one smart pointer to another
a_ptr1       = rcp(ra_ptr1); // Assign from a raw pointer (only do this once!)
a_ptr1->f();                 // Access a member using ->
ra_ptr1->f();                // ""
*a_ptr1      = *a_ptr2;      // Dereference the objects and assign
*ra_ptr1     = *ra_ptr2;     // "" 
\end{verbatim}}

What makes smart pointers different however is that the above piece of code
does not create any memory leaks that would have otherwise occurred
if {}\texttt{a\_ptr1} and {}\texttt{a\_ptr2} where raw C++ pointers.

{}\textbf{Warning!} It is not advisable to create a raw pointer using
{}\texttt{new} first and then pass it into a {}\texttt{RefCountPtr<>} in a
different statement as shown above (which breaks Commandment
{}\ref{rcp:cmd:rcp-new}) unless one are 100\% sure of what one is doing.
Subtle issues with multiple inheritance and/or virtual base classes
can result in a runtime segmentation fault on certain platforms (see
Appendix {}\ref{rcp:apdx:mivbc}).  Breaking Commandment
{}\ref{rcp:cmd:rcp-new} just increases the likelihood that a runtime
error will occur on some platforms.

However, these smart reference-counted pointers can not be used
everywhere a raw pointer can.  For instance, the following
statements will not compile

{\scriptsize\begin{verbatim}
a_ptr1++;           // Error, pointer arithmetic ++, --, +, - etc. not defined!
a_ptr1 == ra_ptr1;  // Error, comparision operators ==, !=, <=, >= etc. not defined!
\end{verbatim}}

Since a smart reference-counted pointer can not be used everywhere a
raw C++ pointer can be, there is a means for getting at the raw C++
pointer with the {}\texttt{RefCountPtr<T>::get()} function (same as with
{}\texttt{std::auto\_ptr<T>::get()}).  For example, to check if two
smart pointer objects contain pointers to the same object one would
check:

{\scriptsize\begin{verbatim}
if( a_ptr1.get() == a_ptr2.get() )
    std::cout << "a_ptr1 and a_ptr2 point to the same object\n";
\end{verbatim}}

The goal of {}\texttt{RefCountPtr<>} is not to hide the fact smart
pointers are being used over raw pointers and therefore not all raw
pointer syntax is allowed.

%
\subsection{Conversion of {}\texttt{RefCountPtr<>} objects}
%

The conversion of smart pointers according to existing raw C++ pointer
conversion rules (e.g.~from derived to base classes, from
non-{}\texttt{const} to {}\texttt{const}) is just as easy as with raw
C++ pointers.  For raw C++ pointers, the compiler will implicitly cast
up an inheritance hiearchy (e.g.~{}\texttt{B1 => A} or {}\texttt{E =>
D}).  For smart reference-counted pointers, these implicit conversions
are just as easy thanks to a templated copy constructor (see Figure
{}\ref{rcp:fig:decl} and the discussion in Item 28 in
{}\cite{{}\cite{ref:meyers_1996}}).  For example, the below code compiles
and runs just fine
%
{\scriptsize\begin{verbatim}
RefCountPtr<C>  c_ptr  = rcp(new C);
RefCountPtr<A>  a_ptr  = c_ptr;
RefCountPtr<B1> b1_ptr = c_ptr;
RefCountPtr<D>  d_ptr  = rcp(new E);
\end{verbatim}}
%
To perform other non-implicit type conversions with pointers such as
{}\texttt{static\-\_cast<>}, {}\texttt{const\-\_cast<>} and
{}\texttt{dynamic\-\_cast<>} the namespace {}\texttt{Teuchos} contains the
non-member template functions {}\texttt{rcp\-\_static\-\_cast<>(...)},
{}\texttt{rcp\-\_const\-\_cast<>(...)} and
{}\texttt{rcp\-\_dynamic\-\_cast<>(...)} respectively with the following
prototypes:
%
{\scriptsize\begin{verbatim}
template<class T2, class T1>
RefCountPtr<T2> rcp_static_cast(const RefCountPtr<T1>& p1);

template<class T2, class T1>
RefCountPtr<T2> rcp_const_cast(const RefCountPtr<T1>& p1);

template<class T2, class T1>
RefCountPtr<T2> rcp_dynamic_cast(const RefCountPtr<T1>& p1);
\end{verbatim}}
%
The usage of these conversion template functions looks very similar to
the syntax with raw C++ pointers.  For example
%
{\scriptsize\begin{verbatim}
RefCountPtr<const C>   c_ptr   = rcp(new C);
RefCountPtr<const A>   ca_ptr  = c_ptr;                              // Implicit!
RefCountPtr<const C>   cc_ptr1 = rcp_dynamic_cast<const C>(ca_ptr);  // Safe!
RefCountPtr<const C>   cc_ptr2 = rcp_static_cast<const C>(ca_ptr);   // Unsafe!
RefCountPtr<A>         a_ptr   = rcp_const_cast<A>(ca_ptr);          // Cast away const
\end{verbatim}}
%
Just as with the case with the built-in C++ conversion operators, some
types of conversions will not compile.  For example
%
{\scriptsize\begin{verbatim}
RefCountPtr<C>       c_ptr1 = rcp(new C);
RefCountPtr<A>       a_ptr  = c_ptr;
RefCountPtr<const C> c_ptr2 = rcp_dynamic_cast<const C>(a_ptr);                      // Error!
RefCountPtr<const C> c_ptr3 = rcp_dynamic_cast<const C>(const_cast<const A>(a_ptr)); // Okay!
RefCountPtr<D>  d_ptr  = rcp(new D);
RefCountPtr<E>  e_ptr1 = rcp_dynamic_cast<E>(d_ptr); // Error, D and E are not polymorphic!
RefCountPtr<E>  e_ptr2 = rcp_static_cast<E>(d_ptr);  // Okay, but unchecked!
\end{verbatim}}

\begin{commandment}
Thou shalt only cast between {}\texttt{RefCountPtr<>} objects using the
default copy constructor (for implicit conversions) and the non-member
template functions {}\texttt{rcp\-\_static\-\_cast<>(...)},
{}\texttt{rcp\-\_const\-\_cast<>(...)} and
{}\texttt{rcp\-\_dynamic\-\_cast<>(...)}  described above.
\end{commandment}


%
\section{The proper use of {}\texttt{RefCountPtr<>} and other C++ data types}
%

After the basics of {}\texttt{RefCountPtr<>} are understood its use is
quite strightforward and this class can be used with any built-in or
user-defined concrete or abstract data type.  Therefore, one may ask
why {}\texttt{RefCountPtr<>} should not be used for all objects.  There
is nothing stoping a developer from using {}\texttt{RefCountPtr<>} in
this way but to do so would be overkill.  The most compelling
situation where {}\texttt{RefCountPtr<>} should be used is when a client
needs to maintain a private data member to another object which is of
an abstract type or is an object that is shared with other clients.
Note that {}\texttt{RefCountPtr<>} usually should not be used for
built-in data types such as {}\texttt{int} or {}\texttt{double} unless
there is a desire to allow another client to change the value remotely
(which is rarely a good idea to allow in general).

In this author's opinion, {}\texttt{RefCountPtr<>} should only be used
to wrap an object in situations where the client has more than a
transient relationship to the object.  An example of transient
relationship with an object is one where the object is simpliy passed
into and out of a function and no ``memory'' of the object resides
after the function call finishes.  For example, the following use
of {}\texttt{RefCountPtr<>} is unnecessary
%
{\scriptsize\begin{verbatim}
class SomeClass {
public:
  void someFunction( RefCountPtr<A> a ) { a->f(); }
};
\end{verbatim}}
%
\noindent{}
In the above example, the use of an object {}\texttt{a} of type
{}\texttt{A} is only used during the function invocation and no
``memory'' if the object {}\texttt{a} is maintained.  Another minor
other problem with the above usage is the fact that the object
{}\texttt{a} is passed by value which results in unnecessary
constructor and destructor invocations (if the function is not inlined
as shown above).  A better way to pass the object {}\texttt{a} in the
above example is as follows
%
{\scriptsize\begin{verbatim}
class SomeClass {
public:
  void someFunction( A* a ) { a->f(); }
};
\end{verbatim}}
%
\noindent{}
Not only is there less typing involved but less (be it small) overhead
is required.  The other reason for preferring the last implementation
is that it speaks to the intent of the argument (see Section
{}\ref{rcp:sec:passing-args}).

A non-transient relationship is one where a client maintains a private
data member to an external object that may be shared by another
client.  The following is the example of such a use case.
%
{\scriptsize\begin{verbatim}
class SomeClass {
public:
  SomeClass( const RefCountPtr<A>& a ) : a_(a) {}
  void aFunction() { a_->f(); }
private:
  RefCountPtr<A> a_;
};
\end{verbatim}}
%
\noindent{}
In the above example, the object {}\texttt{a} is maintained using a
private {}\texttt{RefCountPtr<A>} object since it is called on multiple
times within a member function.

Note that the consistent use of {}\texttt{RefCountPtr<>} makes it
possible to skip writing explicit destructors for most classes since
the compiler-generated destructor does exactly the right thing.  In
the above example, if the object {}\texttt{a} was dynamically
allocated before it was passed to the constructor for
{}\texttt{SomeClass} then that object would be maintained automatic
and would not be deleted until the {}\texttt{SomeClass} object was
destroyed and this required no special involvement by the
{}\texttt{SomeClass} object at all.

%
\subsection{Passing {}\texttt{RefCountPtr<>} and other types of objects to and from functions}
\label{rcp:sec:passing-args}
%

Choosing how to write prototypes for functions for passing arguments
to and from functions in languages like C and Fortran is simple since
there are few choices to make.  In C you can either pass an object by
value or by reference (through a pointer).  In Fortran 77 the choice
is even easier (there is no choice) since every variable is passed by
reference.  Passing arrays of objects to and from functions in these
languages is slightly more complicated, but not by much.

On the other had, C++ adds to C the concpets of {}\texttt{const} and
references (i.e.~{}\texttt{type\&}) in addition to pointers
(i.e.~{}\texttt{type*}).  This makes deciding how to pass arguments in
C++ much more complicated than in other languages.  These features,
which where added to C++ for very good technical reasons, when guided
by commonsense idioms can make it more-or-less clear how arguments
sholud be passed to and from functions in C++ based on their purpose.
This discussion presents some of these idioms and how
{}\texttt{RefCountPtr<>} fits in.

In many respects C++ is a highly expressive programming language where
the programmer's intent for an interface or a function prototype can
be decerned just by looking at the C++ declaration and not even
needing to look at auxiliary documentation in many cases.  For
example, if a reference or pointer argument into a function has the
{}\texttt{const} qualifier, then a developer can automatically (and
rightly) assume that the argument will not be changed within the
implementation of the function.  The language tries to help enforce
{}\texttt{const} but, in the end, it is up to the implementer of a
function to honor the promise inherent in the {}\texttt{const}
modifier in the function prototype (for a more detailed discussion of
{}\texttt{const} in C++ see {}\cite[Section
10.2.7.1]{ref:stroustrup_2000}).

There are other ways to take advantage of the C++ language such that
the general nature of arguments passed to and from a function can be
largly discerned just by looking at the C++ prototype for the
function.  The {}\texttt{const} qualifier just mentioned above is one
of the language features which is self-documenting but there are
others.  Another example is passing arrays to and from functions (by
declaring an integer array argument as {}\texttt{int arg[]} instead of
{}\texttt{int* arg} for instance).  Table {}\ref{rcp:tbl:fnc-decl}
shows recommendations for how to pass objects to and from C++
functions in a way that is as self-documenting as possible.

\begin{table}
%
%\fbox{
\begin{minipage}{{}\textwidth}
\begin{tabular}{|c|c|c|}
\hline
argument purpose
& transitive
& non-transitive \\
\hline
non-mutable object (required)
& \begin{minipage}{12ex}
    \begin{center}
    {\tiny .}\\
    {}\texttt{S s} \\
    or \\
    {}\texttt{const S s} \\
    or \\
    {}\texttt{const S \&s} \\
    {\tiny .}
    \end{center}
  \end{minipage}
& {}\texttt{const RefCountPtr<const S> \&s} \\
\hline
non-mutable object (optional)
& {}\texttt{const S *s}
& {}\texttt{const RefCountPtr<const S> \&s} \\
\hline
mutable object
& {}\texttt{S *s}
& {}\texttt{const RefCountPtr<S> \&s} \\
\hline
non-mutable array of objects
& {}\texttt{const S s[]}
& {}\texttt{RefCountPtr<const S> s[]} \\
\hline
mutable array of objects
& {}\texttt{S s[]}
& {}\texttt{RefCountPtr<S> s[]} \\
\hline
\end{tabular}
\begin{center}
C++ declarations for passing small concrete (i.e.~with value
sementics) objects to and from functions for various reasons (where
{}\texttt{S} is a place holder for an actual built-in or user-defined
data type).
\end{center}
\end{minipage}
%} % end fbox
%
\\[5ex]
%
%\fbox{
\begin{minipage}{{}\textwidth}
\begin{tabular}{|c|c|c|}
\hline
argument purpose
& transitive
& non-transitive \\
\hline
non-mutable object (required)
& {}\texttt{const A \&a}
& {}\texttt{const RefCountPtr<const A> \&a} \\
\hline
non-mutable object (optional)
& {}\texttt{const A *a}
& {}\texttt{const RefCountPtr<const A> \&a} \\
\hline
mutable object
& {}\texttt{S *s}
& {}\texttt{const RefCountPtr<A> \&a} \\
\hline
non-mutable array of objects
& {}\texttt{const A* a[]}
& {}\texttt{RefCountPtr<const A> a[]} \\
\hline
mutable array of objects
& {}\texttt{A* a[]}
& {}\texttt{RefCountPtr<A> a[]} \\
\hline
\end{tabular}
\begin{center}
C++ declarations for passing abstract (i.e.~with reference or pointer
sementics) or large concrete objects to and from functions for various
reasons (where {}\texttt{A} is a place holder for an actual abstract C++
base class).
\end{center}
\end{minipage}
%} % end fbox
%
\caption{\label{rcp:tbl:fnc-decl}
Recommendations for declarations for arguments being passed into and
out of C++ functions for various use cases and different types of
objects.}
%
\end{table}

The reasons why the declarations are the way they are in Table
{}\ref{rcp:tbl:fnc-decl} can be found in the references
{}\cite{ref:stroustrup_2000} and {}\cite{ref:meyers_1994}.
Specifically, see the sections ???.  Appendix
{}\ref{rcp:apdx:passing_args} describes each of the use cases shown in
Table {}{}\ref{rcp:tbl:fnc-decl} and how {}\texttt{RefCountPtr<>} fits
in.

%
\section{Advanced features of {}\texttt{RefCountPtr<>}}
%

In this section we describe some advanced featurs of
{}\texttt{RefCountPtr<>} that most programmer will never need to use and
therefore may never need to know about.  However, there are certain
challenging use cases where this functionality is critical to the
success of {}\texttt{RefCountPtr<>} and therefore we describe these
features here.

%
\subsection{Accessing reference-count information}
%

In most situations, clients do not need to know anything about
reference counts but there are use cases where it is helpful if
clients can query as to reference-count information.  For this
purpose, {}\texttt{RefCountPtr<>} contains the member functions
%
{\scriptsize\begin{verbatim}
template<class T> int  RefCountPtr<T>::count() const {...}
template<class T> bool RefCountPtr<T>::has_ownership() const {...}
\end{verbatim}}
%
{}\noindent{}which can be used to ascertain the status of a
reference-counted object.  Specifically, if {}\texttt{ptr} is a
{}\texttt{RefCountPtr<>} object and {}\texttt{(ptr.count()==1 \&\&
ptr.has\_ownership())==true} then the client that owns {}\texttt{ptr}
(where {}\texttt{ptr} is perhaps as a private data member) can infer
that it is the only client that has a reference to the underlying
reference-counted object and, therefore, this client is free to change
the object freely without worry that such a change will affect another
client.

This type of information must be used very carefully but can be very
helpful in simplifying the logic in cerain types of use cases. If this
type of logic is to be used then it must be documented very clearly
since it is easy to falsely show a reference count higher than the
number of clients that really own {}\texttt{RefCountPtr<>} objects to
the reference-counted object.

%
\subsection{Associating extra data with a {}\texttt{RefCountPtr<>} object}
\label{rcp:sec:extra-data}
%

There are situations when a single {}\texttt{RefCountPtr<>} object is
insufficient to completely handle the dynamic memory for an objects.
This occurs when trying to use classes that where written without
dynamic memory allocation in mind.  To demonstrate the issues involved
assume that the following classes are to be reused in a dynamic
environment and where the memory management is to be handled using
{}\texttt{RefCountPtr<>} objects.
%
{\scriptsize\begin{verbatim}
class Base {
public:
  virtual ~Base() {}
  ...
};

class Derived1 : public Base {
  ...
};

class Utility {
  ...
};

class Derived2 : public Base {
public:
  Derived2(const Utility& u) : u_(u) {}
  ...
private:
  const Utility& u_;
};
\end{verbatim}}
%
\noindent{}
Above, every {}\texttt{Derived2} object must have an
assoicated {}\texttt{Utility} object.  The above class {}\texttt{Derived2}
assumes that an object of type {}\texttt{Utility} is allocated
(presumably on the stack or as a global variable) by the client before
it is used to construct a type {}\texttt{Derived2} object.  For example,
the designers of these classes may expect that these classes will be
used in a flat program such as:
%
{\scriptsize\begin{verbatim}
void f(Base* b);

int main() {
  ...
  if(...) {
    Derived1 d1;
    f(d1);
  }
  else {
    ...
    Utility u;
    Derived2(u) d2;
    f(d2);
  }
  ...
  return 0;
}
\end{verbatim}}
%
\noindent{}
In the above types of programs the flow of logic is linear
from beginning to end and it is easy to allocate all of the objects on
the stack.

Now suppose that we wish to create a factory function (see the
``Abstract Factory'' design pattern in {}\cite{ref:gama_et_al_1995})
that dynamically allocates a {}\texttt{Base} object (of concrete type
{}\texttt{Derived1} or {}\texttt{Derived2}) given a runtime flag and
return it using a {}\texttt{RefCountPtr<Base>} object, for instance,
in the following function.
%
{\scriptsize\begin{verbatim}
RefCountPtr<Base> createBase(bool someFlag);
\end{verbatim}}
%
Now let us consider a (naive and incorrect) first implementation of
this function
%
{\scriptsize\begin{verbatim}
RefCountPtr<Base> createBase(bool someFlag)
{
  if(someFlag) {
    return rcp(new Derived1);
  }
  else {
    Utility u;
    return rcp(new Derived2(u));
  }
}
\end{verbatim}}
%
\noindent{}
Anyone who knows C++ 101 knows the problem with the above function.
As soon as the block of code where {}\texttt{u} is allocated (on the
stack) is exited, the created {}\texttt{Derived2(u)} object becomes
invalid before the function even returns.  Another second (naive and
incorrect) implementation of this function might be
%
{\scriptsize\begin{verbatim}
RefCountPtr<Base> createBase(bool someFlag)
{
  if(someFlag) {
    return rcp(new Derived1);
  }
  else {
    Utility *u = new Utility;
    return rcp(new Derived2(*u));
  }
}
\end{verbatim}}
%
\noindent{}
The above implemenation will insure that the {}\texttt{Derived2} object
created and returned from the function will remain valid but a memmory
leak will have been created.  If the function {}\texttt{create\-Base(...)}
is only called a few times in a program then this memory leak will
most likely be harmless but if this function is called too many times,
memory exhaustion will occur.

The solution to this type of problem is to link a
{}\texttt{RefCountPtr<Utility>} object to the created
{}\texttt{RefCountPtr<Derived2>} object so that when all of the 
{}\texttt{RefCountPtr<Derived2>} objects pointed to this object are
deleted (along with its underlying {}\texttt{Derived2} object) the
associated {}\texttt{Utility} object will also be deleted.  The way to
do this is to using the nonmember function
%
{\scriptsize\begin{verbatim}
template<class T1, class T2>
int set_extra_data( const T1 &extra_data, RefCountPtr<T2> *p, int ctx = -1 );
\end{verbatim}}
%
The function {}\texttt{set\-\_extra\-\_data(...)} adds a piece of extra
data of any type to an existing {}\texttt{RefCountPtr<T2>} object.  This
function works with a concept of a context.  By default, the new
object {}\texttt{extra\-\_data} is appended to a list of objects
associated with the {}\texttt{RefCountPtr<T2>} object {}\texttt{*p} and
the context id for this object is returned as an integer from the function.
This context can be used to access the object using one of the nonmember
functions
%
{\scriptsize\begin{verbatim}
template<class T1, class T2>
T1& get_extra_data( RefCountPtr<T2>& p, int ctx );

template<class T1, class T2>
const T1& get_extra_data( const RefCountPtr<T2>& p, int ctx );
\end{verbatim}}
%
\noindent{}
See the doxygen documentation for these functions
for more details.

In many cases, one does not care to save a context so that the
{}\texttt{extra\-\_data} object can be retrieved and in other cases
one does want to retrieve the object.  The concept of a context allows
multiple clients to tack on extra data to a {}\texttt{RefCountPtr<>}
object and retrieve that extra data without stomping on each other.

New let us see how to use the function {}\texttt{set\-\_extra\-\_data(...)}
to correctly implement {}\texttt{create\-Base(...)}
%
{\scriptsize\begin{verbatim}
RefCountPtr<Base> createBase(bool someFlag)
{
  if(someFlag) {
    return rcp(new Derived1);
  }
  else {
    RefCountPtr<Utility> u = rcp(new Utility);
    RefCountPtr<Base> d = rcp(new Derived2(*u));
    set_extra_data( u, &d );
    return d;
  }
}
\end{verbatim}}
%
\noindent{}
Now when the last {}\texttt{RefCountPtr<>} object to the dynamically
allocated {}\texttt{Derived2} object is removed and the
{}\texttt{Derived2} object is deleted, the associated dynamically
allocated {}\texttt{Utility} object will also be deleted.  Note that
extra data associated with a {}\texttt{RefCountPtr<>} object is only
deleted \underline{after} the reference-counted object is deleted.
This is the correct behavior in use cases like described above where
the destructor for {}\texttt{Derived2} may need to call functions on its
aggregate {}\texttt{Utility} object and therefore the utility object
must be valid at this point.

Note that the ability to add extra data to a {}\texttt{RefCountPtr<>}
object is an advanced feature that that most programmer may never need
to use.

ToDo: Discuss how multiple clients can add extra data for a
{}\texttt{RefCountPtr<>} and they can not interfer with each other.

%
\subsection{Customized deallocation through templated {}\texttt{Dealloc} policy objects}
\label{rcp:sec:dealloc}
%

In the most common scenario for the use of {}\texttt{RefCountPtr<>}
object is to manage the lifetime of objects allocated using
{}\texttt{new} and deallocated using {}\texttt{delete}.  Fore these
cases, the built-in behavior in {}\texttt{RefCountPtr<>} does exactly
the right thing.  However, there are situations when one can not
simply call {}\texttt{delete} to deallocate an object.  Some examples
of these situations include:
%
\begin{enumerate}
\item
When reference counts for objects are managed by requiring clients to
explictly call increment and deincrement functions such as is the case
in CORBA {}\cite{ref:corba} and COM {}\cite{ref:com}.  Such an
approach is also presented in {}\cite[Item 29]{ref:meyers_1996}) in
the subsection ``A Reference-Counting Base Class''.  In these
protocals, dellocation occurs automatically behind the scenes when
this other reference count goes to zero.
\item
When objects are managed by certain types of object databases.  In
some object databases, an object that is grabed from the database must
be explictly returned to the database in order to allow proper object
deletion to take place later.
\item
A different reference-counted pointer class is used to initially get
access to the managed object.  For example, if some peer code works
with {}\texttt{boost::shared\_ptr<>} (see {}\cite{ref:boost})
referenced-counted objects and then resident code needs to work with
{}\texttt{RefCountPtr<>} objects.
\end{enumerate}
%
There are also other situations where one can not simply assume to call
{}\texttt{delete} to remove an object.  The bottom line is that in order
to be general, one must allow arbitary policies to be used to
dellocate an object after clients are finished using the object.

{}\texttt{RefCountPtr<>} supports arbitrary deallocation polices using
the concept of a template deallocator object through the following
version of the non-member templated function {}\texttt{rcp(...)}.
%
{\scriptsize\begin{verbatim}
template<class T, class Dealloc_T>
RefCountPtr<T> rcp( T* p, Dealloc_T dealloc, bool owns_mem );
\end{verbatim}}
%
The implementation of the simpler version of {}\texttt{rcp(...)} first
described in Section {}\ref{rcp:sec:init-rcp-objects} uses the default
dallocator class
%
{\scriptsize\begin{verbatim}
template<class T>
class DeallocDelete
{
public:
  typedef T ptr_t;
  void free( T* ptr ) { if(ptr) delete ptr; }
};
\end{verbatim}}
%
All deallocator objects must support the members {}\texttt{ptr\_t} and
{}\texttt{free()}.  The concept of a template policy inteface (also
called function object \cite[Section 18.4]{ref:stroustrup_2000})
should be familiar to semi-advanced users of the STL (part of the
standard C++ library).

To demonstrate the use of a deallocator object, let of assume that we
must wrap objects of type {}\texttt{A} managed by the the following
object database
%
{\scriptsize\begin{verbatim}
class ObjectADB {
  ...
  A& get(int id);
  void release(int id);
  ...
};
\end{verbatim}}
%
In the above object database, objects are accessed and released using
an id.  How this id is specified and determined is not important here.
Now let us suppose that we want to define an abstract factory object
that returns objects of type {}\texttt{A} wrapped in
{}\texttt{RefCountPtr<A>} objects using an object database of type
{}\texttt{ObjectADB} shown above.  For this abstract factory object,
objects of type {}\texttt{A} will be allocated from a list of ids
given to the factory objects.  The outline of this abstract factory
object looks like the following
%
{\scriptsize\begin{verbatim}
class ObjectADBFactory : public AbstractFactory<A> {
public:
  ObjectADBFactory( ObjectADB *db, int num_ids, const int ids[] ) : db_(db), ids_(ids,ids+num_ids) {}
  // Overridden from AbstractFactory
  RefCountPtr<A> create() { ... };
private:
  ObjectADB *db_;
  std::vector ids_;
};
\end{verbatim}}
%
The above abstract factory subclass {}\texttt{ObjectADBFactory}
inherits from a generic {}\texttt{AbstractFactory} base class that
defines a pure virtial method {}\texttt{create()}.  In order to
implement the override of the {}\texttt{create()} method, a
deallocator class must be defined and used.  For this purpose we
define
%
{\scriptsize\begin{verbatim}
template<class A>
class DeallocObjectADB
{
public:
  DeallocObjectADB( ObjectjADB* db, int id ) : db_(db), id_(id) {}
  typedef A ptr_t;
  void free( T* ptr ) { db_->remove(id); }
private:
  ObjectjADB* db_;
  int id_;
  DeallocObjectADB(); // not defined and not to be called!
};
\end{verbatim}}
%
\noindent{}
Above, the default constructor is declared private without an
implementation so to avoid accedental default construction (see Item
27 in {}\cite{ref:meyers_1994}).

Now we can define the implementation of the {}\texttt{create()} function
override below.
%
{\scriptsize\begin{verbatim}
RefCountPtr<A> ObjectADBFactory::create()
{
  TEST_FOR_EXCEPTION( ids_.size()==0, std::runtime_error, "No ids are left!" );
  const int id = ids_.pop();
  return rcp(&db_->get(id),DeallocObjectADB(db_,id),true);
}
\end{verbatim}}
%
The following program shows the use of the above factory class
%
{\scriptsize\begin{verbatim}
int main()
{
  // Create the object database and populate it (and save the ids)
  ObjectADB db;
  std::vector ids;
  ...
  // Create the abstract factory object
  ObjectADBFactory  ftcy(db,ids.size(),&ids[0])
  // Create some A objects and use them
  RefCountPtr<A> a_ptr1 = fcty.create();
  ...
  return 0;
}
\end{verbatim}}
%
In the above program all of the objects of type {}\texttt{A} are
created and removed seamlessly without the client code that interacts
with {}\texttt{RefCountPtr<>} and {}\texttt{AbstractFactory<>} knowing
anything about what is going on under the hood.  Of course, in real
program would not be contained in a flat program like above but the
reader should get the basic idea without requiring it to be spelled
out.

%
\section{Summary}
%

The templated C++ class {}\texttt{RefCountPtr<>} provides a
low-overhead option for (almost) automatic memory management in C++.
This class has been deveoped and refined over many years and has been
proven to improve the quality and consistency of software projects
that use it consistently.  Careful use of {}\texttt{RefCountPtr<>}
eliminates the need to manually call {}\texttt{deltete} when
dynamically allocated objects are no longer needed and helps to reduce
the amount of code that developers have to write (for example, most
classes that use dynamically allocated memory do not need
developer-supplied destructors since the compiler-generated
destructors do exaclty the right thing).

The class {}\texttt{RefCountPtr<>} also has other advanced features
not found in other smart-pointer implementations such as the ability
to tack on extra data and the customization of deallocation policy.
