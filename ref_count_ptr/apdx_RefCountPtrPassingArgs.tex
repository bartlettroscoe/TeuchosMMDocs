%
\section{Passing objects to and from functions: details}
\label{rcp:apdx:passing_args}
%

The purpose of this section is to explain the reasoning behind the
idiom recommendations given in Table {}\ref{rcp:tbl:fnc-decl} for how
to pass objects to and from C++ functions and how
{}\texttt{Ref\-Count\-Ptr<>} fits in with these idioms.  First it
should be stated that many different code projects do not follow these
idioms.  Usually this is because the developers where unaware of these
idioms and why they are useful to follow.  When thinking about how to
use {}\texttt{Ref\-Count\-Ptr<>} the pass references to and from
functions, one should think of a {}\texttt{Ref\-Count\-Ptr<>} object
as though it was really just a raw pointer except that while raw
pointer objects are usually passed by value to a function (which is
very efficient) a {}\texttt{Ref\-Count\-Ptr<>} object on the other
hand should usually be passed by reference (but passing by value is
harmless).

Before getting into great detail as to the why and how of the
recommendations in Table {}\ref{rcp:tbl:fnc-decl}, consider the
following example function prototype.
%
{\scriptsize\begin{verbatim}
void foo1(
  const int              size_x
  ,const double          x[]
  ,const int             size_a
  ,const A*              a[]
  ,const int             size_y
  ,double                y[]
  ,double                *z
  );
\end{verbatim}}
%
By comparing the argument declarations (which use good argument names)
in the above function to the recommendations in Table
{}\ref{rcp:tbl:fnc-decl}, and without looking at any extra
documentation (if it even exists), we already know a lot about the
arguments being passed into and out of this function.  First, it is
clear that {}\texttt{x} is an array of non-mutable {}\texttt{double}
objects with an presumed length of {}\texttt{size\_x}.  Similarly, we
know that {}\texttt{y} is an array of mutable {}\texttt{double}
objects that may be set or modified.  We also know that {}\texttt{z}
is a single mutable {}\texttt{double} object that may be changed
inside of the function.  What the above C++ declarations, however, do
not tell us is whether the arguments {}\texttt{x}, {}\texttt{a},
{}\texttt{y} and {}\texttt{z} are optional (i.e.~a {}\texttt{NULL}
pointer can be passed in for them) or are required (i.e.~a
non-{}\texttt{NULL} pointer can be passed in for them).  We also do
not know if the mutable objects passed in {}\texttt{y} and
{}\texttt{z} are only output arguments or are input/output arguments.
This type of information must be specified in developer-supplied
documentation.  Note that while a required single non-mutable object
such as {}\texttt{z} could be passed using a non-{}\texttt{const}
reference, using a non-{}\texttt{const} reference for such an argument
is usually not advised and this issue is addressed a little later.

Note that the above function {}\texttt{foo(...)} involved all
transitive (i.e.~only accessed with the function) arguments which is
often the case.  Now lets consider the use of non-transitive argument
types as supported using {}\texttt{Ref\-Count\-Ptr<>}.

{\scriptsize\begin{verbatim}
class SomeClass {
public:
  ...
  void foo2(
    const int                                 size_x
    ,double                                   x[]
    ,const RefCountPtr<std::vector<double> >  &y
    )
  {
    y_ = y;
    ...
  }
  ..
private:
  RefCountPtr<std::vector<double> >  y_;
};
\end{verbatim}}

{}\noindent{}The above example function
{}\texttt{SomeClass\-::foo2(...)} is an example where a non-transitive
argument, {}\texttt{y}, is passed into a function and is then
``remembered''.  In this case, the {}\texttt{Ref\-Count\-Ptr<>}
argument {}\texttt{y} is delivering a
{}\texttt{std\-::vector<\-double>} object to be used as private data
for the class object.

%
\subsection{Passing non-mutable objects}
%

Non-mutable objects (i.e.~objects that are passed into a function and
are not modified) can be passed by value or by reference (i.e.~through
a pointer or a reference) and as either single objects or as arrays.
When non-mutable objects are passed to a function using a pointer or a
reference, the declaration should always use the {}\texttt{const}
modifier.  Failure to use the {}\texttt{const} modifier in these cases
goes against the design of the language.  The use of the
{}\texttt{const} modifier both serves as documentation and helps the
implementor of the function avoid accidentally changing the object.
However, when a small concrete object of type {}\texttt{S} (where
{}\texttt{S} is a {}\texttt{double} or {}\texttt{int} for instance) is
being passed it may also be passed by value (with or without the
{}\texttt{const} modifier as shown in the table).  When a concrete
object is passed by value, the {}\texttt{const} modifier does not in
any way affect the client code that calls the function and the
client's copy of the argument is guaranteed not to be changed (where
the {}\texttt{const} modifier does not).  The {}\texttt{const}
modifier only resticts the modification of the copied parameter in the
function implementation.  Some see the use of {}\texttt{const} as a
means to help function implementors from making mistakes while others
see this as a unecessary restiction on the freedom of the function's
implementation.

When a non-mutable input argument is required, it should be passed by
value or by {}\texttt{const} reference.  However, wen a non-mutable
input argument is optional, it must be passed using a pointer since
this pointer can be allowed to be {}\texttt{NULL}.

Arrays of non-mutable objects should either be passed as an array of
objects (i.e.~in the case where the type is a small concrete data type
such as {}\texttt{double}) such as

{\scriptsize\begin{verbatim}
    S s[]
\end{verbatim}}

{}\noindent{}or

{\scriptsize\begin{verbatim}
    const S s[]
\end{verbatim}}

{}\noindent{}or as an array of {}\texttt{const} object pointers (i.e.~in the case
where the type is a large object or the type has reference semantics) such as

{\scriptsize\begin{verbatim}
    const S* s[]
\end{verbatim}}

Note that the syntax {}\texttt{const S s[]} for passing an array of
objects is to be preferred over the pointer syntax {}\texttt{const S
*s}.  This is because that even though the raw pointer syntax is
perfectly legal and proper C++ usage, this form does not allow one to
tell if this pointer is supposed to point to a single object or to an
array of objects and therefore the syntax {}\texttt{const S s[]} is to
be preferred.

Note that it is possible to pass objects as an array of object
references such as

{\scriptsize\begin{verbatim}
    const S& s[]
\end{verbatim}}

{}\noindent{}but it is generally very difficult to initialze the
references right when the array is first created (as is required by
the standard) and therefore it is not recommended to passed objects as
an array of references but instead to use an array of pointers.

Note that there is no a convenient way to help differentiate whether
an array of objects being passed to a function is optional or not such
as is the case with single non-mutable objects.

%
\subsection{Passing mutable objects}
%

Many of the issues involved with passing mutable objects (i.e.~client
maintained objects that are modifed within a function) are the same as
for passing non-mutable objects such as described above but there are
some differences.  First off, objects that are to have their state
changed within a function must be passed using a pointer (or a
reference) and can not be passed by value.

One apparent area of controversy is the issue of whether
non-\texttt{const} reference or non-\texttt{const} pointer arguments
should be used for passing mutable objects to a function.  If the
argument is optional, then the choice is clear and the argument should
be declared as a non-\texttt{const} pointer.  However, if the argument
is required then some would say that a non-\texttt{const} reference
should always be used.  Interested readers should note, however, that
references were added to C++ primarily to support operator overloading
(see {}\cite[Section 3.7]{ref:design_evol_cpp}) and also for return
values.  If one is writting an overloaded operator function that
modifies one of its arguments (such as the stream insertion and
extraction operators {}\texttt{std::istream\& operator<<(std::istream
\&i, ... )} and {}\texttt{std::ostream\& operator>>(std::ostream \&o,
... )} for instance) then a non-\texttt{const} reference argument must
be used (and note the non-\texttt{const} reference return type as
well).  When the function is not an overloaded operator function then
the choice is not so clear.  Strustroup (the original inventor of C++
{}\cite{ref:design_evol_cpp}) makes a case for using
non-\texttt{const} pointers for mutable arguments in most non-operator
functions in {}\cite[Section 5.5]{ref:stroustrup_2000}.  An expanded
case for using non-\texttt{const} pointer arguments for passing
mutable objects to functions can be made in this discussion as well
(ToDo: Add an expanded discussion of the issue of non-\texttt{const}
pointer arguments if there are a lot of objections to this).

However, while references where {}\underline{not} purposefully added
to the language to support non-\texttt{const} pass-by-reference in
non-operator function, there are circumstances where using
non-\texttt{const} reference arguments is to be preferred (ToDo: Give
an example).  The appraoch advocated here is to prefer
non-\texttt{const} pointer arguments in non-operator functions unless
there is a compelling reason to use a non-\texttt{const} reference
instead such as when there is unlikely to be any confusion whether the
argument is going to be changed.  Making this determination requires
experience, taste and in the end is a subjective decision.

While it was stated earlier that {}\texttt{Ref\-Count\-Ptr<>} should
almost always be passed as {}\texttt{const Ref\-Count\-Ptr<>\&}, there
is one use case where a pointer to a {}\texttt{Ref\-Count\-Ptr<>}
object should be passed to a function instead and that is when the
calling client code is to aquire a {}\texttt{Ref\-Count\-Ptr<>} to an
object held by the server code.  When only a single
{}\texttt{Ref\-Count\-Ptr<>} is to be aquired for a sinlge object,
then it usually best to just return a {}\texttt{Ref\-Count\-Ptr<>}
object from function as its return type such as in the case

{\scriptsize\begin{verbatim}
RefCountPtr<Base> createBase(bool someFlag);
\end{verbatim}}

{}\noindent{}described in Section {}\ref{rcp:sec:extra-data}.
However, when more than one {}\texttt{Ref\-Count\-Ptr<>} object is to
be initialized and given to a client, then one should consider passing
pointers to the {}\texttt{Ref\-Count\-Ptr<>} objects to a function
(see the function {}\texttt{setUninitialized()} in Appendix
{}\ref{rcp:apdx:sep-construct-init}).
