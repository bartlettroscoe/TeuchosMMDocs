%
\section{Passing objects to and from functions: details}
\label{rcp:apdx:passing_args}
%

The purpose of this section is to explain the reasoning behind the
idiom recommendations given in Table {}\ref{rcp:tbl:fnc-decl} for how
to pass objects to and from C++ functions and how
{}\texttt{RefCountPtr<>} fits in with these idioms.  Many different
code projects do not follow these idioms.  Usually this is because the
developers were unaware of these idioms and why they are useful to
follow.  When thinking about how to use {}\texttt{RefCountPtr<>} one
should think of a {}\texttt{RefCountPtr<>} object as a raw pointer
except that while raw pointer objects are usually passed by value to a
function (which is very efficient) where a {}\texttt{RefCountPtr<>}
object should usually be passed by reference (but passing by value is
harmless).

%
\subsection{Passing non-mutable objects}
%

ToDo: Discuss the following categories for the cases of concrete
objects, abstract objects and {}\texttt{RefCountPtr<>} objects for
concrete and abstract objects:

\begin{itemize}
\item Non-mutable objects (required)
\item Non-mutable objects (optional)
\item Arrays of non-mutable objects (required and optional)
\end{itemize}

ToDo: Discuss why non-mutable transitive {}\texttt{S} can be
{}\texttt{(S s)} or {}\texttt{(const S s)} or {}\texttt{(const S \&s)}
and what the issues are.

%
\subsection{Passing mutable objects}
%

ToDo: Discuss the following categories for the cases of concrete
objects, abstract objects and {}\texttt{RefCountPtr<>} objects for
concrete and abstract objects:

\begin{itemize}
\item Mutable objects (required)
\item Mutable objects (optional)
\item Arrays of mutable objects (required and optional)
\end{itemize}

One apparent area of controversy is the issue of whether
non-\texttt{const} reference or non-\texttt{const} pointer arguments
should be used for passing mutable objects to a function.  If the
argument is optional, then the choice is clear and the argument should
be declared as a non-\texttt{const} pointer.  However, if the argument
is not optional then some would say that a non-\texttt{const}
reference should always be used.  Interested readers should note,
however, that references were added to C++ primarily to support
operator overloading (see {}\cite[Section 3.7]{ref:design_evol_cpp})
and also for return values.  If one is writting an overloaded operator
function that modifies one of its arguments (such as the stream
insertion and extraction operators {}\texttt{std::istream\&
operator<<(std::istream
\&i, ... )} and {}\texttt{std::ostream\& operator>>(std::ostream \&o,
... )} for instance) then a non-\texttt{const} reference argument must
be used (and note the non-\texttt{const} reference return type as
well).  When the function is not an overloaded operator function then
the choice is not so clear.  Strustroup (the original inventor of C++
{}\cite{ref:design_evol_cpp}) makes a case for using
non-\texttt{const} pointers for mutable arguments in most non-operator
functions in {}\cite[Section 5.5]{ref:stroustrup_2000}.  An expanded
case for using non-\texttt{const} pointer arguments for passing
mutable objects to functions can be made in this discussion as well
(ToDo: Add an expanded discussion of the issue of non-\texttt{const}
pointer arguments if there are a lot of objections to this).

However, while references where {}\underline{not} purposefully added
to the language to support non-\texttt{const} pass-by-reference, there
are circumstances where using non-\texttt{const} reference arguments
is to be perfered (ToDo: Give an example).  The appraoch advocated
here is to prefer non-\texttt{const} pointer arguments in non-operator
functions unless there is a compelling reason to use a
non-\texttt{const} reference instead.  Making this determination
requires experience, taste and in the end is a subjective decision.

There is one use case where a pointer to a {}\texttt{RefCountPtr<>}
object should be passed to a function and that is when the calling
client code is to aquire a {}\texttt{RefCountPtr<>} to an object held
by the server code.  When only a single {}\texttt{RefCountPtr<>} is to
be aquired for a sinlge object, then it usually best to just return
a {}\texttt{RefCountPtr<>} object from function as its return type
such as in the case
%
{\scriptsize\begin{verbatim}
RefCountPtr<Base> createBase(bool someFlag);
\end{verbatim}}
%
{}\noindent{}described in Section {}\ref{rcp:sec:extra-data}.
However, when more than one {}\texttt{RefCountPtr<>} object is to be
initialized to be given to a client, then one should consider passing
pointers to the {}\texttt{RefCountPtr<>} objects to a function (see
the {}\texttt{setUninitialized()} function in the ``seperate
construction and initialization'' idiom in Appendix
{}\ref{rcp:apdx:sep-construct-init}).
