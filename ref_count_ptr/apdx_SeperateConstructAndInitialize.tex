%
\section{The ``separate construction and initialization'' idiom}
\label{rcp:apdx:sep-construct-init}
%

Here we describe an idiom which works most effectively when using
{}\texttt{RefCountPtr<>} for implementing concrete classes (that may
be manipulated using reference (i.e.~pointer) semantics) that
maximizes flexibility and reusability.  This is the concept of
``separate construction and initialization''.  The idea is that if an
class object can be default constructed to a potentially
``uninitialized'' state and then at any time later can be separately
initialized then such a class will have the maximum reusability and
this can not be disputed.  The idiom described here is more effective
for concrete classes which are derived from abstract interface
classes.  It will be shown below that this ``separate construction and
initialization'' idiom also trivially supports the ``initialization
on construction'' idiom which is preferable in many cases and is
advocated by many experts (for example, see {}\cite[Section
10.2.3]{ref:stroustrup_2000} and {}\cite[Item 4]{ref:meyers_1996}).

What many C++ experts fail to recognize, however, is that in many
cases the entities that are best qualified to fully initialize and
object are not in a position, nor should they be forced, to know the
concrete subclass of an objects that they initialize.  To force some
types of entities to both allocate and initialize objects is to complicate the
design and limit the reusability of such entities.

As an example for where it make sense to separate construction and
initialization, consider an object-oriented design for filling spare
matrix objects.  An example of such an interface is the abstract
{}\texttt{Epetra\_\-Row\-Matrix} interface class in the Epetra [???]
package.  {}\texttt{Epetra\_\-Row\-Matrix} defines operations to
insert/replace/sum-into nonzero elements row by row.  It is possible to
write generic code that takes a pre-allocated
{}\texttt{Epetra\_\-Row\-Matrix} object and then initialize this object
with nonzero values.  Such a piece of generic code would be
complicated and perhaps made less reusable if it had to also know the
concrete subclass(es) in order to create the object first and then
initialize it.  This is perhaps not the best example but the reader
should get the general idea behind the argument for the ``separate
construction from initialization'' idiom.

The basics of this ``separate construction and initialization'' idiom
are demonstrated in the following example subclass.

{\scriptsize\begin{verbatim}
class ConcreteClass1 : public AbstractClass {
public:
  ...
private:
    RefCountPtr<A>  a_;
    RefCountPtr<B>  b_;
};
\end{verbatim}}

{}\noindent{}In the above concrete class, {}\texttt{RefCountPtr<>}
objects are maintained to objects of type {}\texttt{A} and
{}\texttt{B}.  Note that the types {}\texttt{A} and/or {}\texttt{B}
may be abstract and in the overall design, {}\texttt{ConcreteClass1}
may not be able to know the concrete types for these objects (this
scenario is the basis for object-oriented design), therefore
necessitating the use of {}\texttt{RefCountPtr<>}.  Hence, the
{}\texttt{A} and/or {}\texttt{B} objects must be allocated by an
external entity and then given to a {}\texttt{ConcreteClass1} object
in order to fully initialize it.

The idiom advocated here is to specify classes like
{}\texttt{ConcreteClass1} as
%
{\scriptsize\begin{verbatim}
class ConcreteClass1 : public AbstractClass {
public:
  ConcreteClass1() {}
  ConcreteClass1( const RefCountPtr<A>& a, const RefCountPtr<B>&  b )
  { initialize(a,b); }
  void initialize( const RefCountPtr<A>& a, const RefCountPtr<B>& b )
  { a_ = a; b_ = b; }
  void uninitialize( RefCountPtr<A> *a = NULL, RefCountPtr<B> *b = NULL )
  { if(a) *a = a_; if(b) *b = b_; a_ = null; b_ = null; }
  ...
private:
    RefCountPtr<A>  a_;
    RefCountPtr<B>  b_;
};
\end{verbatim}}

Note that in the above implementation of {}\texttt{ConcreteClass1}
that an object can be default constructed to an ``uninitialized''
state or can be fully initialized on object creation (using the second
constructor that calls the {}\texttt{initialize()} function).

A client can later uninitialize an object of type
{}\texttt{Concrete\-Class1} and take ownership of the aggregate
{}\texttt{A} and {}\texttt{B} objects by calling the
{}\texttt{uninitialize()} function as

{\scriptsize\begin{verbatim}
ConcreteClass1 cc1;
...
RefCountPtr<A> a;
RefCountPtr<B> b;
cc1.uninitialize(&a,&b);
\end{verbatim}}

{}\noindent{}or could uninitialize a {}\texttt{Concrete\-Class1}
object and not take ownership as

{\scriptsize\begin{verbatim}
ConcreteClass1 cc1;
...
cc1.uninitialize();
\end{verbatim}}

{}\noindent{}In the last example, if {}\texttt{cc1} was the only
client maintaining {}\texttt{RefCountPtr<>} objects to its aggregate
{}\texttt{A} and {}\texttt{B} objects then these objects would be
deallocated during this function call.  This idiom also allows clients
to optionally take ownership of some but not all of the aggregate
objects on uninitialization.  For example, a client could take
ownership of the {}\texttt{B} but allow the {}\texttt{A} to be deleted
as
%
{\scriptsize\begin{verbatim}
ConcreteClass1 cc1;
...
RefCountPtr<B> b;
cc1.uninitialize(NULL,&b);
\end{verbatim}}
%
